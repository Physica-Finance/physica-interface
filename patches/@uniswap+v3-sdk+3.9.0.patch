diff --git a/node_modules/@uniswap/v3-sdk/dist/v3-sdk.cjs.development.js b/node_modules/@uniswap/v3-sdk/dist/v3-sdk.cjs.development.js
index ab591d0..f674c4a 100644
--- a/node_modules/@uniswap/v3-sdk/dist/v3-sdk.cjs.development.js
+++ b/node_modules/@uniswap/v3-sdk/dist/v3-sdk.cjs.development.js
@@ -19,6 +19,321 @@ var IQuoterV2 = _interopDefault(require('@uniswap/swap-router-contracts/artifact
 var IUniswapV3Staker = _interopDefault(require('@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json'));
 var ISwapRouter = _interopDefault(require('@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json'));
 
+function _regeneratorRuntime() {
+  _regeneratorRuntime = function () {
+    return e;
+  };
+  var t,
+    e = {},
+    r = Object.prototype,
+    n = r.hasOwnProperty,
+    o = Object.defineProperty || function (t, e, r) {
+      t[e] = r.value;
+    },
+    i = "function" == typeof Symbol ? Symbol : {},
+    a = i.iterator || "@@iterator",
+    c = i.asyncIterator || "@@asyncIterator",
+    u = i.toStringTag || "@@toStringTag";
+  function define(t, e, r) {
+    return Object.defineProperty(t, e, {
+      value: r,
+      enumerable: !0,
+      configurable: !0,
+      writable: !0
+    }), t[e];
+  }
+  try {
+    define({}, "");
+  } catch (t) {
+    define = function (t, e, r) {
+      return t[e] = r;
+    };
+  }
+  function wrap(t, e, r, n) {
+    var i = e && e.prototype instanceof Generator ? e : Generator,
+      a = Object.create(i.prototype),
+      c = new Context(n || []);
+    return o(a, "_invoke", {
+      value: makeInvokeMethod(t, r, c)
+    }), a;
+  }
+  function tryCatch(t, e, r) {
+    try {
+      return {
+        type: "normal",
+        arg: t.call(e, r)
+      };
+    } catch (t) {
+      return {
+        type: "throw",
+        arg: t
+      };
+    }
+  }
+  e.wrap = wrap;
+  var h = "suspendedStart",
+    l = "suspendedYield",
+    f = "executing",
+    s = "completed",
+    y = {};
+  function Generator() {}
+  function GeneratorFunction() {}
+  function GeneratorFunctionPrototype() {}
+  var p = {};
+  define(p, a, function () {
+    return this;
+  });
+  var d = Object.getPrototypeOf,
+    v = d && d(d(values([])));
+  v && v !== r && n.call(v, a) && (p = v);
+  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
+  function defineIteratorMethods(t) {
+    ["next", "throw", "return"].forEach(function (e) {
+      define(t, e, function (t) {
+        return this._invoke(e, t);
+      });
+    });
+  }
+  function AsyncIterator(t, e) {
+    function invoke(r, o, i, a) {
+      var c = tryCatch(t[r], t, o);
+      if ("throw" !== c.type) {
+        var u = c.arg,
+          h = u.value;
+        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
+          invoke("next", t, i, a);
+        }, function (t) {
+          invoke("throw", t, i, a);
+        }) : e.resolve(h).then(function (t) {
+          u.value = t, i(u);
+        }, function (t) {
+          return invoke("throw", t, i, a);
+        });
+      }
+      a(c.arg);
+    }
+    var r;
+    o(this, "_invoke", {
+      value: function (t, n) {
+        function callInvokeWithMethodAndArg() {
+          return new e(function (e, r) {
+            invoke(t, n, e, r);
+          });
+        }
+        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
+      }
+    });
+  }
+  function makeInvokeMethod(e, r, n) {
+    var o = h;
+    return function (i, a) {
+      if (o === f) throw new Error("Generator is already running");
+      if (o === s) {
+        if ("throw" === i) throw a;
+        return {
+          value: t,
+          done: !0
+        };
+      }
+      for (n.method = i, n.arg = a;;) {
+        var c = n.delegate;
+        if (c) {
+          var u = maybeInvokeDelegate(c, n);
+          if (u) {
+            if (u === y) continue;
+            return u;
+          }
+        }
+        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
+          if (o === h) throw o = s, n.arg;
+          n.dispatchException(n.arg);
+        } else "return" === n.method && n.abrupt("return", n.arg);
+        o = f;
+        var p = tryCatch(e, r, n);
+        if ("normal" === p.type) {
+          if (o = n.done ? s : l, p.arg === y) continue;
+          return {
+            value: p.arg,
+            done: n.done
+          };
+        }
+        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
+      }
+    };
+  }
+  function maybeInvokeDelegate(e, r) {
+    var n = r.method,
+      o = e.iterator[n];
+    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
+    var i = tryCatch(o, e.iterator, r.arg);
+    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
+    var a = i.arg;
+    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
+  }
+  function pushTryEntry(t) {
+    var e = {
+      tryLoc: t[0]
+    };
+    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
+  }
+  function resetTryEntry(t) {
+    var e = t.completion || {};
+    e.type = "normal", delete e.arg, t.completion = e;
+  }
+  function Context(t) {
+    this.tryEntries = [{
+      tryLoc: "root"
+    }], t.forEach(pushTryEntry, this), this.reset(!0);
+  }
+  function values(e) {
+    if (e || "" === e) {
+      var r = e[a];
+      if (r) return r.call(e);
+      if ("function" == typeof e.next) return e;
+      if (!isNaN(e.length)) {
+        var o = -1,
+          i = function next() {
+            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
+            return next.value = t, next.done = !0, next;
+          };
+        return i.next = i;
+      }
+    }
+    throw new TypeError(typeof e + " is not iterable");
+  }
+  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
+    value: GeneratorFunctionPrototype,
+    configurable: !0
+  }), o(GeneratorFunctionPrototype, "constructor", {
+    value: GeneratorFunction,
+    configurable: !0
+  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
+    var e = "function" == typeof t && t.constructor;
+    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
+  }, e.mark = function (t) {
+    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
+  }, e.awrap = function (t) {
+    return {
+      __await: t
+    };
+  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
+    return this;
+  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
+    void 0 === i && (i = Promise);
+    var a = new AsyncIterator(wrap(t, r, n, o), i);
+    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
+      return t.done ? t.value : a.next();
+    });
+  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
+    return this;
+  }), define(g, "toString", function () {
+    return "[object Generator]";
+  }), e.keys = function (t) {
+    var e = Object(t),
+      r = [];
+    for (var n in e) r.push(n);
+    return r.reverse(), function next() {
+      for (; r.length;) {
+        var t = r.pop();
+        if (t in e) return next.value = t, next.done = !1, next;
+      }
+      return next.done = !0, next;
+    };
+  }, e.values = values, Context.prototype = {
+    constructor: Context,
+    reset: function (e) {
+      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
+    },
+    stop: function () {
+      this.done = !0;
+      var t = this.tryEntries[0].completion;
+      if ("throw" === t.type) throw t.arg;
+      return this.rval;
+    },
+    dispatchException: function (e) {
+      if (this.done) throw e;
+      var r = this;
+      function handle(n, o) {
+        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
+      }
+      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
+        var i = this.tryEntries[o],
+          a = i.completion;
+        if ("root" === i.tryLoc) return handle("end");
+        if (i.tryLoc <= this.prev) {
+          var c = n.call(i, "catchLoc"),
+            u = n.call(i, "finallyLoc");
+          if (c && u) {
+            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
+            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
+          } else if (c) {
+            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
+          } else {
+            if (!u) throw new Error("try statement without catch or finally");
+            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
+          }
+        }
+      }
+    },
+    abrupt: function (t, e) {
+      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
+        var o = this.tryEntries[r];
+        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
+          var i = o;
+          break;
+        }
+      }
+      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
+      var a = i ? i.completion : {};
+      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
+    },
+    complete: function (t, e) {
+      if ("throw" === t.type) throw t.arg;
+      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
+    },
+    finish: function (t) {
+      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
+        var r = this.tryEntries[e];
+        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
+      }
+    },
+    catch: function (t) {
+      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
+        var r = this.tryEntries[e];
+        if (r.tryLoc === t) {
+          var n = r.completion;
+          if ("throw" === n.type) {
+            var o = n.arg;
+            resetTryEntry(r);
+          }
+          return o;
+        }
+      }
+      throw new Error("illegal catch attempt");
+    },
+    delegateYield: function (e, r, n) {
+      return this.delegate = {
+        iterator: values(e),
+        resultName: r,
+        nextLoc: n
+      }, "next" === this.method && (this.arg = t), y;
+    }
+  }, e;
+}
+function _toPrimitive(t, r) {
+  if ("object" != typeof t || !t) return t;
+  var e = t[Symbol.toPrimitive];
+  if (void 0 !== e) {
+    var i = e.call(t, r || "default");
+    if ("object" != typeof i) return i;
+    throw new TypeError("@@toPrimitive must return a primitive value.");
+  }
+  return ("string" === r ? String : Number)(t);
+}
+function _toPropertyKey(t) {
+  var i = _toPrimitive(t, "string");
+  return "symbol" == typeof i ? i : String(i);
+}
 function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
   try {
     var info = gen[key](arg);
@@ -27,83 +342,71 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
-
   if (info.done) {
     resolve(value);
   } else {
     Promise.resolve(value).then(_next, _throw);
   }
 }
-
 function _asyncToGenerator(fn) {
   return function () {
     var self = this,
-        args = arguments;
+      args = arguments;
     return new Promise(function (resolve, reject) {
       var gen = fn.apply(self, args);
-
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
-
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
-
       _next(undefined);
     });
   };
 }
-
 function _defineProperties(target, props) {
   for (var i = 0; i < props.length; i++) {
     var descriptor = props[i];
     descriptor.enumerable = descriptor.enumerable || false;
     descriptor.configurable = true;
     if ("value" in descriptor) descriptor.writable = true;
-    Object.defineProperty(target, descriptor.key, descriptor);
+    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
   }
 }
-
 function _createClass(Constructor, protoProps, staticProps) {
   if (protoProps) _defineProperties(Constructor.prototype, protoProps);
   if (staticProps) _defineProperties(Constructor, staticProps);
+  Object.defineProperty(Constructor, "prototype", {
+    writable: false
+  });
   return Constructor;
 }
-
 function _extends() {
-  _extends = Object.assign || function (target) {
+  _extends = Object.assign ? Object.assign.bind() : function (target) {
     for (var i = 1; i < arguments.length; i++) {
       var source = arguments[i];
-
       for (var key in source) {
         if (Object.prototype.hasOwnProperty.call(source, key)) {
           target[key] = source[key];
         }
       }
     }
-
     return target;
   };
-
   return _extends.apply(this, arguments);
 }
-
 function _objectWithoutPropertiesLoose(source, excluded) {
   if (source == null) return {};
   var target = {};
   var sourceKeys = Object.keys(source);
   var key, i;
-
   for (i = 0; i < sourceKeys.length; i++) {
     key = sourceKeys[i];
     if (excluded.indexOf(key) >= 0) continue;
     target[key] = source[key];
   }
-
   return target;
 }
-
 function _unsupportedIterableToArray(o, minLen) {
   if (!o) return;
   if (typeof o === "string") return _arrayLikeToArray(o, minLen);
@@ -112,800 +415,34 @@ function _unsupportedIterableToArray(o, minLen) {
   if (n === "Map" || n === "Set") return Array.from(o);
   if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
 }
-
 function _arrayLikeToArray(arr, len) {
   if (len == null || len > arr.length) len = arr.length;
-
   for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
-
   return arr2;
 }
-
 function _createForOfIteratorHelperLoose(o, allowArrayLike) {
-  var it;
-
-  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
-    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
-      if (it) o = it;
-      var i = 0;
-      return function () {
-        if (i >= o.length) return {
-          done: true
-        };
-        return {
-          done: false,
-          value: o[i++]
-        };
+  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
+  if (it) return (it = it.call(o)).next.bind(it);
+  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
+    if (it) o = it;
+    var i = 0;
+    return function () {
+      if (i >= o.length) return {
+        done: true
+      };
+      return {
+        done: false,
+        value: o[i++]
       };
-    }
-
-    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
-  }
-
-  it = o[Symbol.iterator]();
-  return it.next.bind(it);
-}
-
-function createCommonjsModule(fn, module) {
-	return module = { exports: {} }, fn(module, module.exports), module.exports;
-}
-
-var runtime_1 = createCommonjsModule(function (module) {
-/**
- * Copyright (c) 2014-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-var runtime = (function (exports) {
-
-  var Op = Object.prototype;
-  var hasOwn = Op.hasOwnProperty;
-  var undefined$1; // More compressible than void 0.
-  var $Symbol = typeof Symbol === "function" ? Symbol : {};
-  var iteratorSymbol = $Symbol.iterator || "@@iterator";
-  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
-  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
-
-  function define(obj, key, value) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-    return obj[key];
-  }
-  try {
-    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
-    define({}, "");
-  } catch (err) {
-    define = function(obj, key, value) {
-      return obj[key] = value;
-    };
-  }
-
-  function wrap(innerFn, outerFn, self, tryLocsList) {
-    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
-    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
-    var generator = Object.create(protoGenerator.prototype);
-    var context = new Context(tryLocsList || []);
-
-    // The ._invoke method unifies the implementations of the .next,
-    // .throw, and .return methods.
-    generator._invoke = makeInvokeMethod(innerFn, self, context);
-
-    return generator;
-  }
-  exports.wrap = wrap;
-
-  // Try/catch helper to minimize deoptimizations. Returns a completion
-  // record like context.tryEntries[i].completion. This interface could
-  // have been (and was previously) designed to take a closure to be
-  // invoked without arguments, but in all the cases we care about we
-  // already have an existing method we want to call, so there's no need
-  // to create a new function object. We can even get away with assuming
-  // the method takes exactly one argument, since that happens to be true
-  // in every case, so we don't have to touch the arguments object. The
-  // only additional allocation required is the completion record, which
-  // has a stable shape and so hopefully should be cheap to allocate.
-  function tryCatch(fn, obj, arg) {
-    try {
-      return { type: "normal", arg: fn.call(obj, arg) };
-    } catch (err) {
-      return { type: "throw", arg: err };
-    }
-  }
-
-  var GenStateSuspendedStart = "suspendedStart";
-  var GenStateSuspendedYield = "suspendedYield";
-  var GenStateExecuting = "executing";
-  var GenStateCompleted = "completed";
-
-  // Returning this object from the innerFn has the same effect as
-  // breaking out of the dispatch switch statement.
-  var ContinueSentinel = {};
-
-  // Dummy constructor functions that we use as the .constructor and
-  // .constructor.prototype properties for functions that return Generator
-  // objects. For full spec compliance, you may wish to configure your
-  // minifier not to mangle the names of these two functions.
-  function Generator() {}
-  function GeneratorFunction() {}
-  function GeneratorFunctionPrototype() {}
-
-  // This is a polyfill for %IteratorPrototype% for environments that
-  // don't natively support it.
-  var IteratorPrototype = {};
-  IteratorPrototype[iteratorSymbol] = function () {
-    return this;
-  };
-
-  var getProto = Object.getPrototypeOf;
-  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
-  if (NativeIteratorPrototype &&
-      NativeIteratorPrototype !== Op &&
-      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
-    // This environment has a native %IteratorPrototype%; use it instead
-    // of the polyfill.
-    IteratorPrototype = NativeIteratorPrototype;
-  }
-
-  var Gp = GeneratorFunctionPrototype.prototype =
-    Generator.prototype = Object.create(IteratorPrototype);
-  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
-  GeneratorFunctionPrototype.constructor = GeneratorFunction;
-  GeneratorFunction.displayName = define(
-    GeneratorFunctionPrototype,
-    toStringTagSymbol,
-    "GeneratorFunction"
-  );
-
-  // Helper for defining the .next, .throw, and .return methods of the
-  // Iterator interface in terms of a single ._invoke method.
-  function defineIteratorMethods(prototype) {
-    ["next", "throw", "return"].forEach(function(method) {
-      define(prototype, method, function(arg) {
-        return this._invoke(method, arg);
-      });
-    });
-  }
-
-  exports.isGeneratorFunction = function(genFun) {
-    var ctor = typeof genFun === "function" && genFun.constructor;
-    return ctor
-      ? ctor === GeneratorFunction ||
-        // For the native GeneratorFunction constructor, the best we can
-        // do is to check its .name property.
-        (ctor.displayName || ctor.name) === "GeneratorFunction"
-      : false;
-  };
-
-  exports.mark = function(genFun) {
-    if (Object.setPrototypeOf) {
-      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
-    } else {
-      genFun.__proto__ = GeneratorFunctionPrototype;
-      define(genFun, toStringTagSymbol, "GeneratorFunction");
-    }
-    genFun.prototype = Object.create(Gp);
-    return genFun;
-  };
-
-  // Within the body of any async function, `await x` is transformed to
-  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
-  // `hasOwn.call(value, "__await")` to determine if the yielded value is
-  // meant to be awaited.
-  exports.awrap = function(arg) {
-    return { __await: arg };
-  };
-
-  function AsyncIterator(generator, PromiseImpl) {
-    function invoke(method, arg, resolve, reject) {
-      var record = tryCatch(generator[method], generator, arg);
-      if (record.type === "throw") {
-        reject(record.arg);
-      } else {
-        var result = record.arg;
-        var value = result.value;
-        if (value &&
-            typeof value === "object" &&
-            hasOwn.call(value, "__await")) {
-          return PromiseImpl.resolve(value.__await).then(function(value) {
-            invoke("next", value, resolve, reject);
-          }, function(err) {
-            invoke("throw", err, resolve, reject);
-          });
-        }
-
-        return PromiseImpl.resolve(value).then(function(unwrapped) {
-          // When a yielded Promise is resolved, its final value becomes
-          // the .value of the Promise<{value,done}> result for the
-          // current iteration.
-          result.value = unwrapped;
-          resolve(result);
-        }, function(error) {
-          // If a rejected Promise was yielded, throw the rejection back
-          // into the async generator function so it can be handled there.
-          return invoke("throw", error, resolve, reject);
-        });
-      }
-    }
-
-    var previousPromise;
-
-    function enqueue(method, arg) {
-      function callInvokeWithMethodAndArg() {
-        return new PromiseImpl(function(resolve, reject) {
-          invoke(method, arg, resolve, reject);
-        });
-      }
-
-      return previousPromise =
-        // If enqueue has been called before, then we want to wait until
-        // all previous Promises have been resolved before calling invoke,
-        // so that results are always delivered in the correct order. If
-        // enqueue has not been called before, then it is important to
-        // call invoke immediately, without waiting on a callback to fire,
-        // so that the async generator function has the opportunity to do
-        // any necessary setup in a predictable way. This predictability
-        // is why the Promise constructor synchronously invokes its
-        // executor callback, and why async functions synchronously
-        // execute code before the first await. Since we implement simple
-        // async functions in terms of async generators, it is especially
-        // important to get this right, even though it requires care.
-        previousPromise ? previousPromise.then(
-          callInvokeWithMethodAndArg,
-          // Avoid propagating failures to Promises returned by later
-          // invocations of the iterator.
-          callInvokeWithMethodAndArg
-        ) : callInvokeWithMethodAndArg();
-    }
-
-    // Define the unified helper method that is used to implement .next,
-    // .throw, and .return (see defineIteratorMethods).
-    this._invoke = enqueue;
-  }
-
-  defineIteratorMethods(AsyncIterator.prototype);
-  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
-    return this;
-  };
-  exports.AsyncIterator = AsyncIterator;
-
-  // Note that simple async functions are implemented on top of
-  // AsyncIterator objects; they just return a Promise for the value of
-  // the final result produced by the iterator.
-  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
-    if (PromiseImpl === void 0) PromiseImpl = Promise;
-
-    var iter = new AsyncIterator(
-      wrap(innerFn, outerFn, self, tryLocsList),
-      PromiseImpl
-    );
-
-    return exports.isGeneratorFunction(outerFn)
-      ? iter // If outerFn is a generator, return the full iterator.
-      : iter.next().then(function(result) {
-          return result.done ? result.value : iter.next();
-        });
-  };
-
-  function makeInvokeMethod(innerFn, self, context) {
-    var state = GenStateSuspendedStart;
-
-    return function invoke(method, arg) {
-      if (state === GenStateExecuting) {
-        throw new Error("Generator is already running");
-      }
-
-      if (state === GenStateCompleted) {
-        if (method === "throw") {
-          throw arg;
-        }
-
-        // Be forgiving, per 25.3.3.3.3 of the spec:
-        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
-        return doneResult();
-      }
-
-      context.method = method;
-      context.arg = arg;
-
-      while (true) {
-        var delegate = context.delegate;
-        if (delegate) {
-          var delegateResult = maybeInvokeDelegate(delegate, context);
-          if (delegateResult) {
-            if (delegateResult === ContinueSentinel) continue;
-            return delegateResult;
-          }
-        }
-
-        if (context.method === "next") {
-          // Setting context._sent for legacy support of Babel's
-          // function.sent implementation.
-          context.sent = context._sent = context.arg;
-
-        } else if (context.method === "throw") {
-          if (state === GenStateSuspendedStart) {
-            state = GenStateCompleted;
-            throw context.arg;
-          }
-
-          context.dispatchException(context.arg);
-
-        } else if (context.method === "return") {
-          context.abrupt("return", context.arg);
-        }
-
-        state = GenStateExecuting;
-
-        var record = tryCatch(innerFn, self, context);
-        if (record.type === "normal") {
-          // If an exception is thrown from innerFn, we leave state ===
-          // GenStateExecuting and loop back for another invocation.
-          state = context.done
-            ? GenStateCompleted
-            : GenStateSuspendedYield;
-
-          if (record.arg === ContinueSentinel) {
-            continue;
-          }
-
-          return {
-            value: record.arg,
-            done: context.done
-          };
-
-        } else if (record.type === "throw") {
-          state = GenStateCompleted;
-          // Dispatch the exception by looping back around to the
-          // context.dispatchException(context.arg) call above.
-          context.method = "throw";
-          context.arg = record.arg;
-        }
-      }
-    };
-  }
-
-  // Call delegate.iterator[context.method](context.arg) and handle the
-  // result, either by returning a { value, done } result from the
-  // delegate iterator, or by modifying context.method and context.arg,
-  // setting context.delegate to null, and returning the ContinueSentinel.
-  function maybeInvokeDelegate(delegate, context) {
-    var method = delegate.iterator[context.method];
-    if (method === undefined$1) {
-      // A .throw or .return when the delegate iterator has no .throw
-      // method always terminates the yield* loop.
-      context.delegate = null;
-
-      if (context.method === "throw") {
-        // Note: ["return"] must be used for ES3 parsing compatibility.
-        if (delegate.iterator["return"]) {
-          // If the delegate iterator has a return method, give it a
-          // chance to clean up.
-          context.method = "return";
-          context.arg = undefined$1;
-          maybeInvokeDelegate(delegate, context);
-
-          if (context.method === "throw") {
-            // If maybeInvokeDelegate(context) changed context.method from
-            // "return" to "throw", let that override the TypeError below.
-            return ContinueSentinel;
-          }
-        }
-
-        context.method = "throw";
-        context.arg = new TypeError(
-          "The iterator does not provide a 'throw' method");
-      }
-
-      return ContinueSentinel;
-    }
-
-    var record = tryCatch(method, delegate.iterator, context.arg);
-
-    if (record.type === "throw") {
-      context.method = "throw";
-      context.arg = record.arg;
-      context.delegate = null;
-      return ContinueSentinel;
-    }
-
-    var info = record.arg;
-
-    if (! info) {
-      context.method = "throw";
-      context.arg = new TypeError("iterator result is not an object");
-      context.delegate = null;
-      return ContinueSentinel;
-    }
-
-    if (info.done) {
-      // Assign the result of the finished delegate to the temporary
-      // variable specified by delegate.resultName (see delegateYield).
-      context[delegate.resultName] = info.value;
-
-      // Resume execution at the desired location (see delegateYield).
-      context.next = delegate.nextLoc;
-
-      // If context.method was "throw" but the delegate handled the
-      // exception, let the outer generator proceed normally. If
-      // context.method was "next", forget context.arg since it has been
-      // "consumed" by the delegate iterator. If context.method was
-      // "return", allow the original .return call to continue in the
-      // outer generator.
-      if (context.method !== "return") {
-        context.method = "next";
-        context.arg = undefined$1;
-      }
-
-    } else {
-      // Re-yield the result returned by the delegate method.
-      return info;
-    }
-
-    // The delegate iterator is finished, so forget it and continue with
-    // the outer generator.
-    context.delegate = null;
-    return ContinueSentinel;
-  }
-
-  // Define Generator.prototype.{next,throw,return} in terms of the
-  // unified ._invoke helper method.
-  defineIteratorMethods(Gp);
-
-  define(Gp, toStringTagSymbol, "Generator");
-
-  // A Generator should always return itself as the iterator object when the
-  // @@iterator function is called on it. Some browsers' implementations of the
-  // iterator prototype chain incorrectly implement this, causing the Generator
-  // object to not be returned from this call. This ensures that doesn't happen.
-  // See https://github.com/facebook/regenerator/issues/274 for more details.
-  Gp[iteratorSymbol] = function() {
-    return this;
-  };
-
-  Gp.toString = function() {
-    return "[object Generator]";
-  };
-
-  function pushTryEntry(locs) {
-    var entry = { tryLoc: locs[0] };
-
-    if (1 in locs) {
-      entry.catchLoc = locs[1];
-    }
-
-    if (2 in locs) {
-      entry.finallyLoc = locs[2];
-      entry.afterLoc = locs[3];
-    }
-
-    this.tryEntries.push(entry);
-  }
-
-  function resetTryEntry(entry) {
-    var record = entry.completion || {};
-    record.type = "normal";
-    delete record.arg;
-    entry.completion = record;
-  }
-
-  function Context(tryLocsList) {
-    // The root entry object (effectively a try statement without a catch
-    // or a finally block) gives us a place to store values thrown from
-    // locations where there is no enclosing try statement.
-    this.tryEntries = [{ tryLoc: "root" }];
-    tryLocsList.forEach(pushTryEntry, this);
-    this.reset(true);
-  }
-
-  exports.keys = function(object) {
-    var keys = [];
-    for (var key in object) {
-      keys.push(key);
-    }
-    keys.reverse();
-
-    // Rather than returning an object with a next method, we keep
-    // things simple and return the next function itself.
-    return function next() {
-      while (keys.length) {
-        var key = keys.pop();
-        if (key in object) {
-          next.value = key;
-          next.done = false;
-          return next;
-        }
-      }
-
-      // To avoid creating an additional object, we just hang the .value
-      // and .done properties off the next function object itself. This
-      // also ensures that the minifier will not anonymize the function.
-      next.done = true;
-      return next;
     };
-  };
-
-  function values(iterable) {
-    if (iterable) {
-      var iteratorMethod = iterable[iteratorSymbol];
-      if (iteratorMethod) {
-        return iteratorMethod.call(iterable);
-      }
-
-      if (typeof iterable.next === "function") {
-        return iterable;
-      }
-
-      if (!isNaN(iterable.length)) {
-        var i = -1, next = function next() {
-          while (++i < iterable.length) {
-            if (hasOwn.call(iterable, i)) {
-              next.value = iterable[i];
-              next.done = false;
-              return next;
-            }
-          }
-
-          next.value = undefined$1;
-          next.done = true;
-
-          return next;
-        };
-
-        return next.next = next;
-      }
-    }
-
-    // Return an iterator with no values.
-    return { next: doneResult };
-  }
-  exports.values = values;
-
-  function doneResult() {
-    return { value: undefined$1, done: true };
   }
-
-  Context.prototype = {
-    constructor: Context,
-
-    reset: function(skipTempReset) {
-      this.prev = 0;
-      this.next = 0;
-      // Resetting context._sent for legacy support of Babel's
-      // function.sent implementation.
-      this.sent = this._sent = undefined$1;
-      this.done = false;
-      this.delegate = null;
-
-      this.method = "next";
-      this.arg = undefined$1;
-
-      this.tryEntries.forEach(resetTryEntry);
-
-      if (!skipTempReset) {
-        for (var name in this) {
-          // Not sure about the optimal order of these conditions:
-          if (name.charAt(0) === "t" &&
-              hasOwn.call(this, name) &&
-              !isNaN(+name.slice(1))) {
-            this[name] = undefined$1;
-          }
-        }
-      }
-    },
-
-    stop: function() {
-      this.done = true;
-
-      var rootEntry = this.tryEntries[0];
-      var rootRecord = rootEntry.completion;
-      if (rootRecord.type === "throw") {
-        throw rootRecord.arg;
-      }
-
-      return this.rval;
-    },
-
-    dispatchException: function(exception) {
-      if (this.done) {
-        throw exception;
-      }
-
-      var context = this;
-      function handle(loc, caught) {
-        record.type = "throw";
-        record.arg = exception;
-        context.next = loc;
-
-        if (caught) {
-          // If the dispatched exception was caught by a catch block,
-          // then let that catch block handle the exception normally.
-          context.method = "next";
-          context.arg = undefined$1;
-        }
-
-        return !! caught;
-      }
-
-      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-        var entry = this.tryEntries[i];
-        var record = entry.completion;
-
-        if (entry.tryLoc === "root") {
-          // Exception thrown outside of any try block that could handle
-          // it, so set the completion value of the entire function to
-          // throw the exception.
-          return handle("end");
-        }
-
-        if (entry.tryLoc <= this.prev) {
-          var hasCatch = hasOwn.call(entry, "catchLoc");
-          var hasFinally = hasOwn.call(entry, "finallyLoc");
-
-          if (hasCatch && hasFinally) {
-            if (this.prev < entry.catchLoc) {
-              return handle(entry.catchLoc, true);
-            } else if (this.prev < entry.finallyLoc) {
-              return handle(entry.finallyLoc);
-            }
-
-          } else if (hasCatch) {
-            if (this.prev < entry.catchLoc) {
-              return handle(entry.catchLoc, true);
-            }
-
-          } else if (hasFinally) {
-            if (this.prev < entry.finallyLoc) {
-              return handle(entry.finallyLoc);
-            }
-
-          } else {
-            throw new Error("try statement without catch or finally");
-          }
-        }
-      }
-    },
-
-    abrupt: function(type, arg) {
-      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-        var entry = this.tryEntries[i];
-        if (entry.tryLoc <= this.prev &&
-            hasOwn.call(entry, "finallyLoc") &&
-            this.prev < entry.finallyLoc) {
-          var finallyEntry = entry;
-          break;
-        }
-      }
-
-      if (finallyEntry &&
-          (type === "break" ||
-           type === "continue") &&
-          finallyEntry.tryLoc <= arg &&
-          arg <= finallyEntry.finallyLoc) {
-        // Ignore the finally entry if control is not jumping to a
-        // location outside the try/catch block.
-        finallyEntry = null;
-      }
-
-      var record = finallyEntry ? finallyEntry.completion : {};
-      record.type = type;
-      record.arg = arg;
-
-      if (finallyEntry) {
-        this.method = "next";
-        this.next = finallyEntry.finallyLoc;
-        return ContinueSentinel;
-      }
-
-      return this.complete(record);
-    },
-
-    complete: function(record, afterLoc) {
-      if (record.type === "throw") {
-        throw record.arg;
-      }
-
-      if (record.type === "break" ||
-          record.type === "continue") {
-        this.next = record.arg;
-      } else if (record.type === "return") {
-        this.rval = this.arg = record.arg;
-        this.method = "return";
-        this.next = "end";
-      } else if (record.type === "normal" && afterLoc) {
-        this.next = afterLoc;
-      }
-
-      return ContinueSentinel;
-    },
-
-    finish: function(finallyLoc) {
-      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-        var entry = this.tryEntries[i];
-        if (entry.finallyLoc === finallyLoc) {
-          this.complete(entry.completion, entry.afterLoc);
-          resetTryEntry(entry);
-          return ContinueSentinel;
-        }
-      }
-    },
-
-    "catch": function(tryLoc) {
-      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-        var entry = this.tryEntries[i];
-        if (entry.tryLoc === tryLoc) {
-          var record = entry.completion;
-          if (record.type === "throw") {
-            var thrown = record.arg;
-            resetTryEntry(entry);
-          }
-          return thrown;
-        }
-      }
-
-      // The context.catch method must only be called with a location
-      // argument that corresponds to a known catch block.
-      throw new Error("illegal catch attempt");
-    },
-
-    delegateYield: function(iterable, resultName, nextLoc) {
-      this.delegate = {
-        iterator: values(iterable),
-        resultName: resultName,
-        nextLoc: nextLoc
-      };
-
-      if (this.method === "next") {
-        // Deliberately forget the last sent value so that we don't
-        // accidentally pass it on to the delegate.
-        this.arg = undefined$1;
-      }
-
-      return ContinueSentinel;
-    }
-  };
-
-  // Regardless of whether this script is executing as a CommonJS module
-  // or not, return the runtime object so that we can declare the variable
-  // regeneratorRuntime in the outer scope, which allows this module to be
-  // injected easily by `bin/regenerator --include-runtime script.js`.
-  return exports;
-
-}(
-  // If this script is executing as a CommonJS module, use module.exports
-  // as the regeneratorRuntime namespace. Otherwise create a new empty
-  // object. Either way, the resulting object will be used to initialize
-  // the regeneratorRuntime variable at the top of this file.
-   module.exports 
-));
-
-try {
-  regeneratorRuntime = runtime;
-} catch (accidentalStrictMode) {
-  // This module should not be running in strict mode, so the above
-  // assignment should always work unless something is misconfigured. Just
-  // in case runtime.js accidentally runs in strict mode, we can escape
-  // strict mode using a global Function call. This could conceivably fail
-  // if a Content Security Policy forbids using Function, but in that case
-  // the proper solution is to fix the accidental strict mode problem. If
-  // you've misconfigured your bundler to force strict mode and applied a
-  // CSP to forbid Function, and you're not willing to fix either of those
-  // problems, please detail your unique predicament in a GitHub issue.
-  Function("r", "regeneratorRuntime = r")(runtime);
+  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
 }
-});
 
 var _TICK_SPACINGS;
-
 var FACTORY_ADDRESS = '0x1F98431c8aD98523631AE4a59f267346ea31F984';
 var ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
 var POOL_INIT_CODE_HASH = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54';
-
 (function (FeeAmount) {
   FeeAmount[FeeAmount["LOWEST"] = 100] = "LOWEST";
   FeeAmount[FeeAmount["LOW"] = 500] = "LOW";
@@ -915,14 +452,13 @@ var POOL_INIT_CODE_HASH = '0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea8932
 /**
  * The default factory tick spacings by fee amount.
  */
-
-
 var TICK_SPACINGS = (_TICK_SPACINGS = {}, _TICK_SPACINGS[exports.FeeAmount.LOWEST] = 1, _TICK_SPACINGS[exports.FeeAmount.LOW] = 10, _TICK_SPACINGS[exports.FeeAmount.MEDIUM] = 60, _TICK_SPACINGS[exports.FeeAmount.HIGH] = 200, _TICK_SPACINGS);
 
+// constants used internally but not expected to be used externally
 var NEGATIVE_ONE = /*#__PURE__*/JSBI.BigInt(-1);
 var ZERO = /*#__PURE__*/JSBI.BigInt(0);
-var ONE = /*#__PURE__*/JSBI.BigInt(1); // used in liquidity amount math
-
+var ONE = /*#__PURE__*/JSBI.BigInt(1);
+// used in liquidity amount math
 var Q96 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(96));
 var Q192 = /*#__PURE__*/JSBI.exponentiate(Q96, /*#__PURE__*/JSBI.BigInt(2));
 
@@ -935,19 +471,15 @@ var Q192 = /*#__PURE__*/JSBI.exponentiate(Q96, /*#__PURE__*/JSBI.BigInt(2));
  * @param initCodeHashManualOverride Override the init code hash used to compute the pool address if necessary
  * @returns The pool address
  */
-
 function computePoolAddress(_ref) {
   var factoryAddress = _ref.factoryAddress,
-      tokenA = _ref.tokenA,
-      tokenB = _ref.tokenB,
-      fee = _ref.fee,
-      initCodeHashManualOverride = _ref.initCodeHashManualOverride;
-
+    tokenA = _ref.tokenA,
+    tokenB = _ref.tokenB,
+    fee = _ref.fee,
+    initCodeHashManualOverride = _ref.initCodeHashManualOverride;
   var _ref2 = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA],
-      token0 = _ref2[0],
-      token1 = _ref2[1]; // does safety checks
-
-
+    token0 = _ref2[0],
+    token1 = _ref2[1]; // does safety checks
   return address.getCreate2Address(factoryAddress, solidity.keccak256(['bytes'], [abi.defaultAbiCoder.encode(['address', 'address', 'uint24'], [token0.address, token1.address, fee])]), initCodeHashManualOverride != null ? initCodeHashManualOverride : POOL_INIT_CODE_HASH);
 }
 
@@ -956,7 +488,6 @@ var LiquidityMath = /*#__PURE__*/function () {
    * Cannot be constructed.
    */
   function LiquidityMath() {}
-
   LiquidityMath.addDelta = function addDelta(x, y) {
     if (JSBI.lessThan(y, ZERO)) {
       return JSBI.subtract(x, JSBI.multiply(y, NEGATIVE_ONE));
@@ -964,7 +495,6 @@ var LiquidityMath = /*#__PURE__*/function () {
       return JSBI.add(x, y);
     }
   };
-
   return LiquidityMath;
 }();
 
@@ -973,109 +503,87 @@ var FullMath = /*#__PURE__*/function () {
    * Cannot be constructed.
    */
   function FullMath() {}
-
   FullMath.mulDivRoundingUp = function mulDivRoundingUp(a, b, denominator) {
     var product = JSBI.multiply(a, b);
     var result = JSBI.divide(product, denominator);
     if (JSBI.notEqual(JSBI.remainder(product, denominator), ZERO)) result = JSBI.add(result, ONE);
     return result;
   };
-
   return FullMath;
 }();
 
 var MaxUint160 = /*#__PURE__*/JSBI.subtract( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(160)), ONE);
-
 function multiplyIn256(x, y) {
   var product = JSBI.multiply(x, y);
   return JSBI.bitwiseAnd(product, sdkCore.MaxUint256);
 }
-
 function addIn256(x, y) {
   var sum = JSBI.add(x, y);
   return JSBI.bitwiseAnd(sum, sdkCore.MaxUint256);
 }
-
 var SqrtPriceMath = /*#__PURE__*/function () {
   /**
    * Cannot be constructed.
    */
   function SqrtPriceMath() {}
-
   SqrtPriceMath.getAmount0Delta = function getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
     if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
       var _ref = [sqrtRatioBX96, sqrtRatioAX96];
       sqrtRatioAX96 = _ref[0];
       sqrtRatioBX96 = _ref[1];
     }
-
     var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
     var numerator2 = JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96);
     return roundUp ? FullMath.mulDivRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), ONE, sqrtRatioAX96) : JSBI.divide(JSBI.divide(JSBI.multiply(numerator1, numerator2), sqrtRatioBX96), sqrtRatioAX96);
   };
-
   SqrtPriceMath.getAmount1Delta = function getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
     if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
       var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
       sqrtRatioAX96 = _ref2[0];
       sqrtRatioBX96 = _ref2[1];
     }
-
     return roundUp ? FullMath.mulDivRoundingUp(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96), Q96) : JSBI.divide(JSBI.multiply(liquidity, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96)), Q96);
   };
-
   SqrtPriceMath.getNextSqrtPriceFromInput = function getNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne) {
     !JSBI.greaterThan(sqrtPX96, ZERO) ?  invariant(false)  : void 0;
     !JSBI.greaterThan(liquidity, ZERO) ?  invariant(false)  : void 0;
     return zeroForOne ? this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true) : this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
   };
-
   SqrtPriceMath.getNextSqrtPriceFromOutput = function getNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne) {
     !JSBI.greaterThan(sqrtPX96, ZERO) ?  invariant(false)  : void 0;
     !JSBI.greaterThan(liquidity, ZERO) ?  invariant(false)  : void 0;
     return zeroForOne ? this.getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false) : this.getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
   };
-
   SqrtPriceMath.getNextSqrtPriceFromAmount0RoundingUp = function getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amount, add) {
     if (JSBI.equal(amount, ZERO)) return sqrtPX96;
     var numerator1 = JSBI.leftShift(liquidity, JSBI.BigInt(96));
-
     if (add) {
       var product = multiplyIn256(amount, sqrtPX96);
-
       if (JSBI.equal(JSBI.divide(product, amount), sqrtPX96)) {
         var denominator = addIn256(numerator1, product);
-
         if (JSBI.greaterThanOrEqual(denominator, numerator1)) {
           return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator);
         }
       }
-
       return FullMath.mulDivRoundingUp(numerator1, ONE, JSBI.add(JSBI.divide(numerator1, sqrtPX96), amount));
     } else {
       var _product = multiplyIn256(amount, sqrtPX96);
-
       !JSBI.equal(JSBI.divide(_product, amount), sqrtPX96) ?  invariant(false)  : void 0;
       !JSBI.greaterThan(numerator1, _product) ?  invariant(false)  : void 0;
-
       var _denominator = JSBI.subtract(numerator1, _product);
-
       return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, _denominator);
     }
   };
-
   SqrtPriceMath.getNextSqrtPriceFromAmount1RoundingDown = function getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amount, add) {
     if (add) {
       var quotient = JSBI.lessThanOrEqual(amount, MaxUint160) ? JSBI.divide(JSBI.leftShift(amount, JSBI.BigInt(96)), liquidity) : JSBI.divide(JSBI.multiply(amount, Q96), liquidity);
       return JSBI.add(sqrtPX96, quotient);
     } else {
       var _quotient = FullMath.mulDivRoundingUp(amount, Q96, liquidity);
-
       !JSBI.greaterThan(sqrtPX96, _quotient) ?  invariant(false)  : void 0;
       return JSBI.subtract(sqrtPX96, _quotient);
     }
   };
-
   return SqrtPriceMath;
 }();
 
@@ -1085,16 +593,13 @@ var SwapMath = /*#__PURE__*/function () {
    * Cannot be constructed.
    */
   function SwapMath() {}
-
   SwapMath.computeSwapStep = function computeSwapStep(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, amountRemaining, feePips) {
     var returnValues = {};
     var zeroForOne = JSBI.greaterThanOrEqual(sqrtRatioCurrentX96, sqrtRatioTargetX96);
     var exactIn = JSBI.greaterThanOrEqual(amountRemaining, ZERO);
-
     if (exactIn) {
       var amountRemainingLessFee = JSBI.divide(JSBI.multiply(amountRemaining, JSBI.subtract(MAX_FEE, JSBI.BigInt(feePips))), MAX_FEE);
       returnValues.amountIn = zeroForOne ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true) : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
-
       if (JSBI.greaterThanOrEqual(amountRemainingLessFee, returnValues.amountIn)) {
         returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
       } else {
@@ -1102,16 +607,13 @@ var SwapMath = /*#__PURE__*/function () {
       }
     } else {
       returnValues.amountOut = zeroForOne ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false) : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
-
       if (JSBI.greaterThanOrEqual(JSBI.multiply(amountRemaining, NEGATIVE_ONE), returnValues.amountOut)) {
         returnValues.sqrtRatioNextX96 = sqrtRatioTargetX96;
       } else {
         returnValues.sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(sqrtRatioCurrentX96, liquidity, JSBI.multiply(amountRemaining, NEGATIVE_ONE), zeroForOne);
       }
     }
-
     var max = JSBI.equal(sqrtRatioTargetX96, returnValues.sqrtRatioNextX96);
-
     if (zeroForOne) {
       returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount0Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
       returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount1Delta(returnValues.sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
@@ -1119,21 +621,17 @@ var SwapMath = /*#__PURE__*/function () {
       returnValues.amountIn = max && exactIn ? returnValues.amountIn : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, true);
       returnValues.amountOut = max && !exactIn ? returnValues.amountOut : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, returnValues.sqrtRatioNextX96, liquidity, false);
     }
-
     if (!exactIn && JSBI.greaterThan(returnValues.amountOut, JSBI.multiply(amountRemaining, NEGATIVE_ONE))) {
       returnValues.amountOut = JSBI.multiply(amountRemaining, NEGATIVE_ONE);
     }
-
     if (exactIn && JSBI.notEqual(returnValues.sqrtRatioNextX96, sqrtRatioTargetX96)) {
       // we didn't reach the target, so take the remainder of the maximum input as fee
       returnValues.feeAmount = JSBI.subtract(amountRemaining, returnValues.amountIn);
     } else {
       returnValues.feeAmount = FullMath.mulDivRoundingUp(returnValues.amountIn, JSBI.BigInt(feePips), JSBI.subtract(MAX_FEE, JSBI.BigInt(feePips)));
     }
-
     return [returnValues.sqrtRatioNextX96, returnValues.amountIn, returnValues.amountOut, returnValues.feeAmount];
   };
-
   return SwapMath;
 }();
 
@@ -1145,25 +643,21 @@ function mostSignificantBit(x) {
   !JSBI.greaterThan(x, ZERO) ?  invariant(false, 'ZERO')  : void 0;
   !JSBI.lessThanOrEqual(x, sdkCore.MaxUint256) ?  invariant(false, 'MAX')  : void 0;
   var msb = 0;
-
   for (var _iterator = _createForOfIteratorHelperLoose(POWERS_OF_2), _step; !(_step = _iterator()).done;) {
     var _step$value = _step.value,
-        power = _step$value[0],
-        min = _step$value[1];
-
+      power = _step$value[0],
+      min = _step$value[1];
     if (JSBI.greaterThanOrEqual(x, min)) {
       x = JSBI.signedRightShift(x, JSBI.BigInt(power));
       msb += power;
     }
   }
-
   return msb;
 }
 
 function mulShift(val, mulBy) {
   return JSBI.signedRightShift(JSBI.multiply(val, JSBI.BigInt(mulBy)), JSBI.BigInt(128));
 }
-
 var Q32 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(32));
 var TickMath = /*#__PURE__*/function () {
   /**
@@ -1174,90 +668,77 @@ var TickMath = /*#__PURE__*/function () {
    * Returns the sqrt ratio as a Q64.96 for the given tick. The sqrt ratio is computed as sqrt(1.0001)^tick
    * @param tick the tick for which to compute the sqrt ratio
    */
-
-
   TickMath.getSqrtRatioAtTick = function getSqrtRatioAtTick(tick) {
     !(tick >= TickMath.MIN_TICK && tick <= TickMath.MAX_TICK && Number.isInteger(tick)) ?  invariant(false, 'TICK')  : void 0;
     var absTick = tick < 0 ? tick * -1 : tick;
-    var ratio = (absTick & 0x1) != 0 ? JSBI.BigInt('0xfffcb933bd6fad37aa2d162d1a594001') : JSBI.BigInt('0x100000000000000000000000000000000');
-    if ((absTick & 0x2) != 0) ratio = mulShift(ratio, '0xfff97272373d413259a46990580e213a');
-    if ((absTick & 0x4) != 0) ratio = mulShift(ratio, '0xfff2e50f5f656932ef12357cf3c7fdcc');
-    if ((absTick & 0x8) != 0) ratio = mulShift(ratio, '0xffe5caca7e10e4e61c3624eaa0941cd0');
-    if ((absTick & 0x10) != 0) ratio = mulShift(ratio, '0xffcb9843d60f6159c9db58835c926644');
-    if ((absTick & 0x20) != 0) ratio = mulShift(ratio, '0xff973b41fa98c081472e6896dfb254c0');
-    if ((absTick & 0x40) != 0) ratio = mulShift(ratio, '0xff2ea16466c96a3843ec78b326b52861');
-    if ((absTick & 0x80) != 0) ratio = mulShift(ratio, '0xfe5dee046a99a2a811c461f1969c3053');
-    if ((absTick & 0x100) != 0) ratio = mulShift(ratio, '0xfcbe86c7900a88aedcffc83b479aa3a4');
-    if ((absTick & 0x200) != 0) ratio = mulShift(ratio, '0xf987a7253ac413176f2b074cf7815e54');
-    if ((absTick & 0x400) != 0) ratio = mulShift(ratio, '0xf3392b0822b70005940c7a398e4b70f3');
-    if ((absTick & 0x800) != 0) ratio = mulShift(ratio, '0xe7159475a2c29b7443b29c7fa6e889d9');
-    if ((absTick & 0x1000) != 0) ratio = mulShift(ratio, '0xd097f3bdfd2022b8845ad8f792aa5825');
-    if ((absTick & 0x2000) != 0) ratio = mulShift(ratio, '0xa9f746462d870fdf8a65dc1f90e061e5');
-    if ((absTick & 0x4000) != 0) ratio = mulShift(ratio, '0x70d869a156d2a1b890bb3df62baf32f7');
-    if ((absTick & 0x8000) != 0) ratio = mulShift(ratio, '0x31be135f97d08fd981231505542fcfa6');
-    if ((absTick & 0x10000) != 0) ratio = mulShift(ratio, '0x9aa508b5b7a84e1c677de54f3e99bc9');
-    if ((absTick & 0x20000) != 0) ratio = mulShift(ratio, '0x5d6af8dedb81196699c329225ee604');
-    if ((absTick & 0x40000) != 0) ratio = mulShift(ratio, '0x2216e584f5fa1ea926041bedfe98');
-    if ((absTick & 0x80000) != 0) ratio = mulShift(ratio, '0x48a170391f7dc42444e8fa2');
-    if (tick > 0) ratio = JSBI.divide(sdkCore.MaxUint256, ratio); // back to Q96
-
+    var ratio = (absTick & 0x1) !== 0 ? JSBI.BigInt('0xfffcb933bd6fad37aa2d162d1a594001') : JSBI.BigInt('0x100000000000000000000000000000000');
+    if ((absTick & 0x2) !== 0) ratio = mulShift(ratio, '0xfff97272373d413259a46990580e213a');
+    if ((absTick & 0x4) !== 0) ratio = mulShift(ratio, '0xfff2e50f5f656932ef12357cf3c7fdcc');
+    if ((absTick & 0x8) !== 0) ratio = mulShift(ratio, '0xffe5caca7e10e4e61c3624eaa0941cd0');
+    if ((absTick & 0x10) !== 0) ratio = mulShift(ratio, '0xffcb9843d60f6159c9db58835c926644');
+    if ((absTick & 0x20) !== 0) ratio = mulShift(ratio, '0xff973b41fa98c081472e6896dfb254c0');
+    if ((absTick & 0x40) !== 0) ratio = mulShift(ratio, '0xff2ea16466c96a3843ec78b326b52861');
+    if ((absTick & 0x80) !== 0) ratio = mulShift(ratio, '0xfe5dee046a99a2a811c461f1969c3053');
+    if ((absTick & 0x100) !== 0) ratio = mulShift(ratio, '0xfcbe86c7900a88aedcffc83b479aa3a4');
+    if ((absTick & 0x200) !== 0) ratio = mulShift(ratio, '0xf987a7253ac413176f2b074cf7815e54');
+    if ((absTick & 0x400) !== 0) ratio = mulShift(ratio, '0xf3392b0822b70005940c7a398e4b70f3');
+    if ((absTick & 0x800) !== 0) ratio = mulShift(ratio, '0xe7159475a2c29b7443b29c7fa6e889d9');
+    if ((absTick & 0x1000) !== 0) ratio = mulShift(ratio, '0xd097f3bdfd2022b8845ad8f792aa5825');
+    if ((absTick & 0x2000) !== 0) ratio = mulShift(ratio, '0xa9f746462d870fdf8a65dc1f90e061e5');
+    if ((absTick & 0x4000) !== 0) ratio = mulShift(ratio, '0x70d869a156d2a1b890bb3df62baf32f7');
+    if ((absTick & 0x8000) !== 0) ratio = mulShift(ratio, '0x31be135f97d08fd981231505542fcfa6');
+    if ((absTick & 0x10000) !== 0) ratio = mulShift(ratio, '0x9aa508b5b7a84e1c677de54f3e99bc9');
+    if ((absTick & 0x20000) !== 0) ratio = mulShift(ratio, '0x5d6af8dedb81196699c329225ee604');
+    if ((absTick & 0x40000) !== 0) ratio = mulShift(ratio, '0x2216e584f5fa1ea926041bedfe98');
+    if ((absTick & 0x80000) !== 0) ratio = mulShift(ratio, '0x48a170391f7dc42444e8fa2');
+    if (tick > 0) ratio = JSBI.divide(sdkCore.MaxUint256, ratio);
+    // back to Q96
     return JSBI.greaterThan(JSBI.remainder(ratio, Q32), ZERO) ? JSBI.add(JSBI.divide(ratio, Q32), ONE) : JSBI.divide(ratio, Q32);
   }
   /**
    * Returns the tick corresponding to a given sqrt ratio, s.t. #getSqrtRatioAtTick(tick) <= sqrtRatioX96
    * and #getSqrtRatioAtTick(tick + 1) > sqrtRatioX96
    * @param sqrtRatioX96 the sqrt ratio as a Q64.96 for which to compute the tick
-   */
-  ;
-
+   */;
   TickMath.getTickAtSqrtRatio = function getTickAtSqrtRatio(sqrtRatioX96) {
     !(JSBI.greaterThanOrEqual(sqrtRatioX96, TickMath.MIN_SQRT_RATIO) && JSBI.lessThan(sqrtRatioX96, TickMath.MAX_SQRT_RATIO)) ?  invariant(false, 'SQRT_RATIO')  : void 0;
     var sqrtRatioX128 = JSBI.leftShift(sqrtRatioX96, JSBI.BigInt(32));
     var msb = mostSignificantBit(sqrtRatioX128);
     var r;
-
     if (JSBI.greaterThanOrEqual(JSBI.BigInt(msb), JSBI.BigInt(128))) {
       r = JSBI.signedRightShift(sqrtRatioX128, JSBI.BigInt(msb - 127));
     } else {
       r = JSBI.leftShift(sqrtRatioX128, JSBI.BigInt(127 - msb));
     }
-
     var log_2 = JSBI.leftShift(JSBI.subtract(JSBI.BigInt(msb), JSBI.BigInt(128)), JSBI.BigInt(64));
-
     for (var i = 0; i < 14; i++) {
       r = JSBI.signedRightShift(JSBI.multiply(r, r), JSBI.BigInt(127));
       var f = JSBI.signedRightShift(r, JSBI.BigInt(128));
       log_2 = JSBI.bitwiseOr(log_2, JSBI.leftShift(f, JSBI.BigInt(63 - i)));
       r = JSBI.signedRightShift(r, f);
     }
-
     var log_sqrt10001 = JSBI.multiply(log_2, JSBI.BigInt('255738958999603826347141'));
     var tickLow = JSBI.toNumber(JSBI.signedRightShift(JSBI.subtract(log_sqrt10001, JSBI.BigInt('3402992956809132418596140100660247210')), JSBI.BigInt(128)));
     var tickHigh = JSBI.toNumber(JSBI.signedRightShift(JSBI.add(log_sqrt10001, JSBI.BigInt('291339464771989622907027621153398088495')), JSBI.BigInt(128)));
     return tickLow === tickHigh ? tickLow : JSBI.lessThanOrEqual(TickMath.getSqrtRatioAtTick(tickHigh), sqrtRatioX96) ? tickHigh : tickLow;
   };
-
   return TickMath;
 }();
 /**
  * The minimum tick that can be used on any pool.
  */
-
 TickMath.MIN_TICK = -887272;
 /**
  * The maximum tick that can be used on any pool.
  */
-
 TickMath.MAX_TICK = -TickMath.MIN_TICK;
 /**
  * The sqrt ratio corresponding to the minimum tick that could be used on any pool.
  */
-
 TickMath.MIN_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('4295128739');
 /**
  * The sqrt ratio corresponding to the maximum tick that could be used on any pool.
  */
-
 TickMath.MAX_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('1461446703485210103287273052203988822378723970342');
 
 /**
@@ -1266,55 +747,41 @@ TickMath.MAX_SQRT_RATIO = /*#__PURE__*/JSBI.BigInt('1461446703485210103287273052
  */
 var NoTickDataProvider = /*#__PURE__*/function () {
   function NoTickDataProvider() {}
-
   var _proto = NoTickDataProvider.prototype;
-
   _proto.getTick = /*#__PURE__*/function () {
-    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(_tick) {
-      return runtime_1.wrap(function _callee$(_context) {
-        while (1) {
-          switch (_context.prev = _context.next) {
-            case 0:
-              throw new Error(NoTickDataProvider.ERROR_MESSAGE);
-
-            case 1:
-            case "end":
-              return _context.stop();
-          }
+    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_tick) {
+      return _regeneratorRuntime().wrap(function _callee$(_context) {
+        while (1) switch (_context.prev = _context.next) {
+          case 0:
+            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
+          case 1:
+          case "end":
+            return _context.stop();
         }
       }, _callee);
     }));
-
     function getTick(_x) {
       return _getTick.apply(this, arguments);
     }
-
     return getTick;
   }();
-
   _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/function () {
-    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(_tick, _lte, _tickSpacing) {
-      return runtime_1.wrap(function _callee2$(_context2) {
-        while (1) {
-          switch (_context2.prev = _context2.next) {
-            case 0:
-              throw new Error(NoTickDataProvider.ERROR_MESSAGE);
-
-            case 1:
-            case "end":
-              return _context2.stop();
-          }
+    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_tick, _lte, _tickSpacing) {
+      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
+        while (1) switch (_context2.prev = _context2.next) {
+          case 0:
+            throw new Error(NoTickDataProvider.ERROR_MESSAGE);
+          case 1:
+          case "end":
+            return _context2.stop();
         }
       }, _callee2);
     }));
-
     function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
       return _nextInitializedTickWithinOneWord.apply(this, arguments);
     }
-
     return nextInitializedTickWithinOneWord;
   }();
-
   return NoTickDataProvider;
 }();
 NoTickDataProvider.ERROR_MESSAGE = 'No tick data provider was given';
@@ -1331,7 +798,6 @@ function isSorted(list, comparator) {
       return false;
     }
   }
-
   return true;
 }
 
@@ -1341,39 +807,33 @@ function tickComparator(a, b) {
 /**
  * Utility methods for interacting with sorted lists of ticks
  */
-
-
 var TickList = /*#__PURE__*/function () {
   /**
    * Cannot be constructed
    */
   function TickList() {}
-
   TickList.validateList = function validateList(ticks, tickSpacing) {
-    !(tickSpacing > 0) ?  invariant(false, 'TICK_SPACING_NONZERO')  : void 0; // ensure ticks are spaced appropriately
-
+    !(tickSpacing > 0) ?  invariant(false, 'TICK_SPACING_NONZERO')  : void 0;
+    // ensure ticks are spaced appropriately
     !ticks.every(function (_ref) {
       var index = _ref.index;
       return index % tickSpacing === 0;
-    }) ?  invariant(false, 'TICK_SPACING')  : void 0; // ensure tick liquidity deltas sum to 0
-
+    }) ?  invariant(false, 'TICK_SPACING')  : void 0;
+    // ensure tick liquidity deltas sum to 0
     !JSBI.equal(ticks.reduce(function (accumulator, _ref2) {
       var liquidityNet = _ref2.liquidityNet;
       return JSBI.add(accumulator, liquidityNet);
     }, ZERO), ZERO) ?  invariant(false, 'ZERO_NET')  : void 0;
     !isSorted(ticks, tickComparator) ?  invariant(false, 'SORTED')  : void 0;
   };
-
   TickList.isBelowSmallest = function isBelowSmallest(ticks, tick) {
     !(ticks.length > 0) ?  invariant(false, 'LENGTH')  : void 0;
     return tick < ticks[0].index;
   };
-
   TickList.isAtOrAboveLargest = function isAtOrAboveLargest(ticks, tick) {
     !(ticks.length > 0) ?  invariant(false, 'LENGTH')  : void 0;
     return tick >= ticks[ticks.length - 1].index;
   };
-
   TickList.getTick = function getTick(ticks, index) {
     var tick = ticks[this.binarySearch(ticks, index)];
     !(tick.index === index) ?  invariant(false, 'NOT_CONTAINED')  : void 0;
@@ -1384,22 +844,17 @@ var TickList = /*#__PURE__*/function () {
    * @param ticks list of ticks
    * @param tick tick to find the largest tick that is less than or equal to tick
    * @private
-   */
-  ;
-
+   */;
   TickList.binarySearch = function binarySearch(ticks, tick) {
     !!this.isBelowSmallest(ticks, tick) ?  invariant(false, 'BELOW_SMALLEST')  : void 0;
     var l = 0;
     var r = ticks.length - 1;
     var i;
-
     while (true) {
       i = Math.floor((l + r) / 2);
-
       if (ticks[i].index <= tick && (i === ticks.length - 1 || ticks[i + 1].index > tick)) {
         return i;
       }
-
       if (ticks[i].index < tick) {
         l = i + 1;
       } else {
@@ -1407,61 +862,45 @@ var TickList = /*#__PURE__*/function () {
       }
     }
   };
-
   TickList.nextInitializedTick = function nextInitializedTick(ticks, tick, lte) {
     if (lte) {
       !!TickList.isBelowSmallest(ticks, tick) ?  invariant(false, 'BELOW_SMALLEST')  : void 0;
-
       if (TickList.isAtOrAboveLargest(ticks, tick)) {
         return ticks[ticks.length - 1];
       }
-
       var index = this.binarySearch(ticks, tick);
       return ticks[index];
     } else {
       !!this.isAtOrAboveLargest(ticks, tick) ?  invariant(false, 'AT_OR_ABOVE_LARGEST')  : void 0;
-
       if (this.isBelowSmallest(ticks, tick)) {
         return ticks[0];
       }
-
       var _index = this.binarySearch(ticks, tick);
-
       return ticks[_index + 1];
     }
   };
-
   TickList.nextInitializedTickWithinOneWord = function nextInitializedTickWithinOneWord(ticks, tick, lte, tickSpacing) {
     var compressed = Math.floor(tick / tickSpacing); // matches rounding in the code
-
     if (lte) {
       var wordPos = compressed >> 8;
       var minimum = (wordPos << 8) * tickSpacing;
-
       if (TickList.isBelowSmallest(ticks, tick)) {
         return [minimum, false];
       }
-
       var index = TickList.nextInitializedTick(ticks, tick, lte).index;
       var nextInitializedTick = Math.max(minimum, index);
       return [nextInitializedTick, nextInitializedTick === index];
     } else {
       var _wordPos = compressed + 1 >> 8;
-
       var maximum = ((_wordPos + 1 << 8) - 1) * tickSpacing;
-
       if (this.isAtOrAboveLargest(ticks, tick)) {
         return [maximum, false];
       }
-
       var _index2 = this.nextInitializedTick(ticks, tick, lte).index;
-
       var _nextInitializedTick = Math.min(maximum, _index2);
-
       return [_nextInitializedTick, _nextInitializedTick === _index2];
     }
   };
-
   return TickList;
 }();
 
@@ -1470,15 +909,12 @@ var TickList = /*#__PURE__*/function () {
  * @param bigintIsh
  * @returns The hex encoded calldata
  */
-
 function toHex(bigintIsh) {
   var bigInt = JSBI.BigInt(bigintIsh);
   var hex = bigInt.toString(16);
-
   if (hex.length % 2 !== 0) {
     hex = "0" + hex;
   }
-
   return "0x" + hex;
 }
 
@@ -1487,37 +923,33 @@ function toHex(bigintIsh) {
  * @param route the v3 path to convert to an encoded path
  * @param exactOutput whether the route should be encoded in reverse, for making exact output swaps
  */
-
 function encodeRouteToPath(route, exactOutput) {
   var firstInputToken = route.input.wrapped;
-
   var _route$pools$reduce = route.pools.reduce(function (_ref, pool, index) {
-    var inputToken = _ref.inputToken,
+      var inputToken = _ref.inputToken,
         path = _ref.path,
         types = _ref.types;
-    var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0;
-
-    if (index === 0) {
-      return {
-        inputToken: outputToken,
-        types: ['address', 'uint24', 'address'],
-        path: [inputToken.address, pool.fee, outputToken.address]
-      };
-    } else {
-      return {
-        inputToken: outputToken,
-        types: [].concat(types, ['uint24', 'address']),
-        path: [].concat(path, [pool.fee, outputToken.address])
-      };
-    }
-  }, {
-    inputToken: firstInputToken,
-    path: [],
-    types: []
-  }),
-      path = _route$pools$reduce.path,
-      types = _route$pools$reduce.types;
-
+      var outputToken = pool.token0.equals(inputToken) ? pool.token1 : pool.token0;
+      if (index === 0) {
+        return {
+          inputToken: outputToken,
+          types: ['address', 'uint24', 'address'],
+          path: [inputToken.address, pool.fee, outputToken.address]
+        };
+      } else {
+        return {
+          inputToken: outputToken,
+          types: [].concat(types, ['uint24', 'address']),
+          path: [].concat(path, [pool.fee, outputToken.address])
+        };
+      }
+    }, {
+      inputToken: firstInputToken,
+      path: [],
+      types: []
+    }),
+    path = _route$pools$reduce.path,
+    types = _route$pools$reduce.types;
   return exactOutput ? solidity.pack(types.reverse(), path.reverse()) : solidity.pack(types, path);
 }
 
@@ -1527,7 +959,6 @@ function encodeRouteToPath(route, exactOutput) {
  * @param amount0 The denominator amount i.e., the amount of token0
  * @returns The sqrt ratio
  */
-
 function encodeSqrtRatioX96(amount1, amount0) {
   var numerator = JSBI.leftShift(JSBI.BigInt(amount1), JSBI.BigInt(192));
   var denominator = JSBI.BigInt(amount0);
@@ -1546,14 +977,12 @@ function encodeSqrtRatioX96(amount1, amount0) {
  * @param amount0 The token0 amount
  * @returns liquidity for amount0, imprecise
  */
-
 function maxLiquidityForAmount0Imprecise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
     var _ref = [sqrtRatioBX96, sqrtRatioAX96];
     sqrtRatioAX96 = _ref[0];
     sqrtRatioBX96 = _ref[1];
   }
-
   var intermediate = JSBI.divide(JSBI.multiply(sqrtRatioAX96, sqrtRatioBX96), Q96);
   return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount0), intermediate), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
 }
@@ -1565,15 +994,12 @@ function maxLiquidityForAmount0Imprecise(sqrtRatioAX96, sqrtRatioBX96, amount0)
  * @param amount0 The token0 amount
  * @returns liquidity for amount0, precise
  */
-
-
 function maxLiquidityForAmount0Precise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
     var _ref2 = [sqrtRatioBX96, sqrtRatioAX96];
     sqrtRatioAX96 = _ref2[0];
     sqrtRatioBX96 = _ref2[1];
   }
-
   var numerator = JSBI.multiply(JSBI.multiply(JSBI.BigInt(amount0), sqrtRatioAX96), sqrtRatioBX96);
   var denominator = JSBI.multiply(Q96, JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
   return JSBI.divide(numerator, denominator);
@@ -1585,15 +1011,12 @@ function maxLiquidityForAmount0Precise(sqrtRatioAX96, sqrtRatioBX96, amount0) {
  * @param amount1 The token1 amount
  * @returns liquidity for amount1
  */
-
-
 function maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
     var _ref3 = [sqrtRatioBX96, sqrtRatioAX96];
     sqrtRatioAX96 = _ref3[0];
     sqrtRatioBX96 = _ref3[1];
   }
-
   return JSBI.divide(JSBI.multiply(JSBI.BigInt(amount1), Q96), JSBI.subtract(sqrtRatioBX96, sqrtRatioAX96));
 }
 /**
@@ -1607,17 +1030,13 @@ function maxLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1) {
  * @param useFullPrecision if false, liquidity will be maximized according to what the router can calculate,
  * not what core can theoretically support
  */
-
-
 function maxLiquidityForAmounts(sqrtRatioCurrentX96, sqrtRatioAX96, sqrtRatioBX96, amount0, amount1, useFullPrecision) {
   if (JSBI.greaterThan(sqrtRatioAX96, sqrtRatioBX96)) {
     var _ref4 = [sqrtRatioBX96, sqrtRatioAX96];
     sqrtRatioAX96 = _ref4[0];
     sqrtRatioBX96 = _ref4[1];
   }
-
   var maxLiquidityForAmount0 = useFullPrecision ? maxLiquidityForAmount0Precise : maxLiquidityForAmount0Imprecise;
-
   if (JSBI.lessThanOrEqual(sqrtRatioCurrentX96, sqrtRatioAX96)) {
     return maxLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
   } else if (JSBI.lessThan(sqrtRatioCurrentX96, sqrtRatioBX96)) {
@@ -1634,7 +1053,6 @@ function maxLiquidityForAmounts(sqrtRatioCurrentX96, sqrtRatioAX96, sqrtRatioBX9
  * @param tick the target tick
  * @param tickSpacing the spacing of the pool
  */
-
 function nearestUsableTick(tick, tickSpacing) {
   !(Number.isInteger(tick) && Number.isInteger(tickSpacing)) ?  invariant(false, 'INTEGERS')  : void 0;
   !(tickSpacing > 0) ?  invariant(false, 'TICK_SPACING')  : void 0;
@@ -1648,15 +1066,13 @@ var PositionLibrary = /*#__PURE__*/function () {
   /**
    * Cannot be constructed.
    */
-  function PositionLibrary() {} // replicates the portions of Position#update required to compute unaccounted fees
-
-
+  function PositionLibrary() {}
+  // replicates the portions of Position#update required to compute unaccounted fees
   PositionLibrary.getTokensOwed = function getTokensOwed(feeGrowthInside0LastX128, feeGrowthInside1LastX128, liquidity, feeGrowthInside0X128, feeGrowthInside1X128) {
     var tokensOwed0 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside0X128, feeGrowthInside0LastX128), liquidity), Q128);
     var tokensOwed1 = JSBI.divide(JSBI.multiply(subIn256(feeGrowthInside1X128, feeGrowthInside1LastX128), liquidity), Q128);
     return [tokensOwed0, tokensOwed1];
   };
-
   return PositionLibrary;
 }();
 
@@ -1667,7 +1083,6 @@ var PositionLibrary = /*#__PURE__*/function () {
  * @param quoteToken the quote token of the price
  * @param tick the tick for which to return the price
  */
-
 function tickToPrice(baseToken, quoteToken, tick) {
   var sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);
   var ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96);
@@ -1678,13 +1093,11 @@ function tickToPrice(baseToken, quoteToken, tick) {
  * @param price for which to return the closest tick that represents a price less than or equal to the input price,
  * i.e. the price of the returned tick is less than or equal to the input price
  */
-
 function priceToClosestTick(price) {
   var sorted = price.baseCurrency.sortsBefore(price.quoteCurrency);
   var sqrtRatioX96 = sorted ? encodeSqrtRatioX96(price.numerator, price.denominator) : encodeSqrtRatioX96(price.denominator, price.numerator);
   var tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96);
   var nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1);
-
   if (sorted) {
     if (!price.lessThan(nextTickPrice)) {
       tick++;
@@ -1694,14 +1107,12 @@ function priceToClosestTick(price) {
       tick++;
     }
   }
-
   return tick;
 }
 
 var Q256 = /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(256));
 function subIn256(x, y) {
   var difference = JSBI.subtract(x, y);
-
   if (JSBI.lessThan(difference, ZERO)) {
     return JSBI.add(Q256, difference);
   } else {
@@ -1713,11 +1124,9 @@ var TickLibrary = /*#__PURE__*/function () {
    * Cannot be constructed.
    */
   function TickLibrary() {}
-
   TickLibrary.getFeeGrowthInside = function getFeeGrowthInside(feeGrowthOutsideLower, feeGrowthOutsideUpper, tickLower, tickUpper, tickCurrent, feeGrowthGlobal0X128, feeGrowthGlobal1X128) {
     var feeGrowthBelow0X128;
     var feeGrowthBelow1X128;
-
     if (tickCurrent >= tickLower) {
       feeGrowthBelow0X128 = feeGrowthOutsideLower.feeGrowthOutside0X128;
       feeGrowthBelow1X128 = feeGrowthOutsideLower.feeGrowthOutside1X128;
@@ -1725,10 +1134,8 @@ var TickLibrary = /*#__PURE__*/function () {
       feeGrowthBelow0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideLower.feeGrowthOutside0X128);
       feeGrowthBelow1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideLower.feeGrowthOutside1X128);
     }
-
     var feeGrowthAbove0X128;
     var feeGrowthAbove1X128;
-
     if (tickCurrent < tickUpper) {
       feeGrowthAbove0X128 = feeGrowthOutsideUpper.feeGrowthOutside0X128;
       feeGrowthAbove1X128 = feeGrowthOutsideUpper.feeGrowthOutside1X128;
@@ -1736,17 +1143,15 @@ var TickLibrary = /*#__PURE__*/function () {
       feeGrowthAbove0X128 = subIn256(feeGrowthGlobal0X128, feeGrowthOutsideUpper.feeGrowthOutside0X128);
       feeGrowthAbove1X128 = subIn256(feeGrowthGlobal1X128, feeGrowthOutsideUpper.feeGrowthOutside1X128);
     }
-
     return [subIn256(subIn256(feeGrowthGlobal0X128, feeGrowthBelow0X128), feeGrowthAbove0X128), subIn256(subIn256(feeGrowthGlobal1X128, feeGrowthBelow1X128), feeGrowthAbove1X128)];
   };
-
   return TickLibrary;
 }();
 
 var Tick = function Tick(_ref) {
   var index = _ref.index,
-      liquidityGross = _ref.liquidityGross,
-      liquidityNet = _ref.liquidityNet;
+    liquidityGross = _ref.liquidityGross,
+    liquidityNet = _ref.liquidityNet;
   !(index >= TickMath.MIN_TICK && index <= TickMath.MAX_TICK) ?  invariant(false, 'TICK')  : void 0;
   this.index = index;
   this.liquidityGross = JSBI.BigInt(liquidityGross);
@@ -1756,7 +1161,6 @@ var Tick = function Tick(_ref) {
 /**
  * A data provider for ticks that is backed by an in-memory array of ticks.
  */
-
 var TickListDataProvider = /*#__PURE__*/function () {
   function TickListDataProvider(ticks, tickSpacing) {
     var ticksMapped = ticks.map(function (t) {
@@ -1765,67 +1169,51 @@ var TickListDataProvider = /*#__PURE__*/function () {
     TickList.validateList(ticksMapped, tickSpacing);
     this.ticks = ticksMapped;
   }
-
   var _proto = TickListDataProvider.prototype;
-
   _proto.getTick = /*#__PURE__*/function () {
-    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(tick) {
-      return runtime_1.wrap(function _callee$(_context) {
-        while (1) {
-          switch (_context.prev = _context.next) {
-            case 0:
-              return _context.abrupt("return", TickList.getTick(this.ticks, tick));
-
-            case 1:
-            case "end":
-              return _context.stop();
-          }
+    var _getTick = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tick) {
+      return _regeneratorRuntime().wrap(function _callee$(_context) {
+        while (1) switch (_context.prev = _context.next) {
+          case 0:
+            return _context.abrupt("return", TickList.getTick(this.ticks, tick));
+          case 1:
+          case "end":
+            return _context.stop();
         }
       }, _callee, this);
     }));
-
     function getTick(_x) {
       return _getTick.apply(this, arguments);
     }
-
     return getTick;
   }();
-
   _proto.nextInitializedTickWithinOneWord = /*#__PURE__*/function () {
-    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(tick, lte, tickSpacing) {
-      return runtime_1.wrap(function _callee2$(_context2) {
-        while (1) {
-          switch (_context2.prev = _context2.next) {
-            case 0:
-              return _context2.abrupt("return", TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing));
-
-            case 1:
-            case "end":
-              return _context2.stop();
-          }
+    var _nextInitializedTickWithinOneWord = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tick, lte, tickSpacing) {
+      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
+        while (1) switch (_context2.prev = _context2.next) {
+          case 0:
+            return _context2.abrupt("return", TickList.nextInitializedTickWithinOneWord(this.ticks, tick, lte, tickSpacing));
+          case 1:
+          case "end":
+            return _context2.stop();
         }
       }, _callee2, this);
     }));
-
     function nextInitializedTickWithinOneWord(_x2, _x3, _x4) {
       return _nextInitializedTickWithinOneWord.apply(this, arguments);
     }
-
     return nextInitializedTickWithinOneWord;
   }();
-
   return TickListDataProvider;
 }();
 
 /**
  * By default, pools will not allow operations that require ticks.
  */
-
 var NO_TICK_DATA_PROVIDER_DEFAULT = /*#__PURE__*/new NoTickDataProvider();
 /**
  * Represents a V3 pool
  */
-
 var Pool = /*#__PURE__*/function () {
   /**
    * Construct a pool
@@ -1841,14 +1229,11 @@ var Pool = /*#__PURE__*/function () {
     if (ticks === void 0) {
       ticks = NO_TICK_DATA_PROVIDER_DEFAULT;
     }
-
     !(Number.isInteger(fee) && fee < 1000000) ?  invariant(false, 'FEE')  : void 0;
     var tickCurrentSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent);
     var nextTickSqrtRatioX96 = TickMath.getSqrtRatioAtTick(tickCurrent + 1);
     !(JSBI.greaterThanOrEqual(JSBI.BigInt(sqrtRatioX96), tickCurrentSqrtRatioX96) && JSBI.lessThanOrEqual(JSBI.BigInt(sqrtRatioX96), nextTickSqrtRatioX96)) ?  invariant(false, 'PRICE_BOUNDS')  : void 0;
-
     var _ref = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
-
     this.token0 = _ref[0];
     this.token1 = _ref[1];
     this.fee = fee;
@@ -1857,7 +1242,6 @@ var Pool = /*#__PURE__*/function () {
     this.tickCurrent = tickCurrent;
     this.tickDataProvider = Array.isArray(ticks) ? new TickListDataProvider(ticks, TICK_SPACINGS[fee]) : ticks;
   }
-
   Pool.getAddress = function getAddress(tokenA, tokenB, fee, initCodeHashManualOverride, factoryAddressOverride) {
     return computePoolAddress({
       factoryAddress: factoryAddressOverride != null ? factoryAddressOverride : FACTORY_ADDRESS,
@@ -1871,19 +1255,14 @@ var Pool = /*#__PURE__*/function () {
    * Returns true if the token is either token0 or token1
    * @param token The token to check
    * @returns True if token is either token0 or token
-   */
-  ;
-
+   */;
   var _proto = Pool.prototype;
-
   _proto.involvesToken = function involvesToken(token) {
     return token.equals(this.token0) || token.equals(this.token1);
   }
   /**
    * Returns the current mid price of the pool in terms of token0, i.e. the ratio of token1 over token0
-   */
-  ;
-
+   */;
   /**
    * Return the price of the given token in terms of the other token in the pool.
    * @param token The token to return price of
@@ -1895,9 +1274,7 @@ var Pool = /*#__PURE__*/function () {
   }
   /**
    * Returns the chain ID of the tokens in the pool.
-   */
-  ;
-
+   */;
   /**
    * Given an input amount of a token, return the computed output amount, and a pool with state updated after the trade
    * @param inputAmount The input amount for which to quote the output amount
@@ -1905,20 +1282,17 @@ var Pool = /*#__PURE__*/function () {
    * @returns The output amount and the pool with updated state
    */
   _proto.getOutputAmount =
-  /*#__PURE__*/
-  function () {
-    var _getOutputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(inputAmount, sqrtPriceLimitX96) {
-      var zeroForOne, _yield$this$swap, outputAmount, sqrtRatioX96, liquidity, tickCurrent, outputToken;
-
-      return runtime_1.wrap(function _callee$(_context) {
-        while (1) {
-          switch (_context.prev = _context.next) {
+    /*#__PURE__*/
+    function () {
+      var _getOutputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(inputAmount, sqrtPriceLimitX96) {
+        var zeroForOne, _yield$this$swap, outputAmount, sqrtRatioX96, liquidity, tickCurrent, outputToken;
+        return _regeneratorRuntime().wrap(function _callee$(_context) {
+          while (1) switch (_context.prev = _context.next) {
             case 0:
               !this.involvesToken(inputAmount.currency) ?  invariant(false, 'TOKEN')  : void 0;
               zeroForOne = inputAmount.currency.equals(this.token0);
               _context.next = 4;
               return this.swap(zeroForOne, inputAmount.quotient, sqrtPriceLimitX96);
-
             case 4:
               _yield$this$swap = _context.sent;
               outputAmount = _yield$this$swap.amountCalculated;
@@ -1927,21 +1301,17 @@ var Pool = /*#__PURE__*/function () {
               tickCurrent = _yield$this$swap.tickCurrent;
               outputToken = zeroForOne ? this.token1 : this.token0;
               return _context.abrupt("return", [sdkCore.CurrencyAmount.fromRawAmount(outputToken, JSBI.multiply(outputAmount, NEGATIVE_ONE)), new Pool(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)]);
-
             case 11:
             case "end":
               return _context.stop();
           }
-        }
-      }, _callee, this);
-    }));
-
-    function getOutputAmount(_x, _x2) {
-      return _getOutputAmount.apply(this, arguments);
-    }
-
-    return getOutputAmount;
-  }()
+        }, _callee, this);
+      }));
+      function getOutputAmount(_x, _x2) {
+        return _getOutputAmount.apply(this, arguments);
+      }
+      return getOutputAmount;
+    }()
   /**
    * Given a desired output amount of a token, return the computed input amount and a pool with state updated after the trade
    * @param outputAmount the output amount for which to quote the input amount
@@ -1949,22 +1319,18 @@ var Pool = /*#__PURE__*/function () {
    * @returns The input amount and the pool with updated state
    */
   ;
-
   _proto.getInputAmount =
-  /*#__PURE__*/
-  function () {
-    var _getInputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(outputAmount, sqrtPriceLimitX96) {
-      var zeroForOne, _yield$this$swap2, inputAmount, sqrtRatioX96, liquidity, tickCurrent, inputToken;
-
-      return runtime_1.wrap(function _callee2$(_context2) {
-        while (1) {
-          switch (_context2.prev = _context2.next) {
+    /*#__PURE__*/
+    function () {
+      var _getInputAmount = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(outputAmount, sqrtPriceLimitX96) {
+        var zeroForOne, _yield$this$swap2, inputAmount, sqrtRatioX96, liquidity, tickCurrent, inputToken;
+        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
+          while (1) switch (_context2.prev = _context2.next) {
             case 0:
               !(outputAmount.currency.isToken && this.involvesToken(outputAmount.currency)) ?  invariant(false, 'TOKEN')  : void 0;
               zeroForOne = outputAmount.currency.equals(this.token1);
               _context2.next = 4;
               return this.swap(zeroForOne, JSBI.multiply(outputAmount.quotient, NEGATIVE_ONE), sqrtPriceLimitX96);
-
             case 4:
               _yield$this$swap2 = _context2.sent;
               inputAmount = _yield$this$swap2.amountCalculated;
@@ -1973,21 +1339,17 @@ var Pool = /*#__PURE__*/function () {
               tickCurrent = _yield$this$swap2.tickCurrent;
               inputToken = zeroForOne ? this.token0 : this.token1;
               return _context2.abrupt("return", [sdkCore.CurrencyAmount.fromRawAmount(inputToken, inputAmount), new Pool(this.token0, this.token1, this.fee, sqrtRatioX96, liquidity, tickCurrent, this.tickDataProvider)]);
-
             case 11:
             case "end":
               return _context2.stop();
           }
-        }
-      }, _callee2, this);
-    }));
-
-    function getInputAmount(_x3, _x4) {
-      return _getInputAmount.apply(this, arguments);
-    }
-
-    return getInputAmount;
-  }()
+        }, _callee2, this);
+      }));
+      function getInputAmount(_x3, _x4) {
+        return _getInputAmount.apply(this, arguments);
+      }
+      return getInputAmount;
+    }()
   /**
    * Executes a swap
    * @param zeroForOne Whether the amount in is token0 or token1
@@ -1999,19 +1361,15 @@ var Pool = /*#__PURE__*/function () {
    * @returns tickCurrent
    */
   ;
-
   _proto.swap =
-  /*#__PURE__*/
-  function () {
-    var _swap = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(zeroForOne, amountSpecified, sqrtPriceLimitX96) {
-      var exactInput, state, step, _yield$this$tickDataP, _SwapMath$computeSwap, liquidityNet;
-
-      return runtime_1.wrap(function _callee3$(_context3) {
-        while (1) {
-          switch (_context3.prev = _context3.next) {
+    /*#__PURE__*/
+    function () {
+      var _swap = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(zeroForOne, amountSpecified, sqrtPriceLimitX96) {
+        var exactInput, state, step, _yield$this$tickDataP, _SwapMath$computeSwap, liquidityNet;
+        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
+          while (1) switch (_context3.prev = _context3.next) {
             case 0:
               if (!sqrtPriceLimitX96) sqrtPriceLimitX96 = zeroForOne ? JSBI.add(TickMath.MIN_SQRT_RATIO, ONE) : JSBI.subtract(TickMath.MAX_SQRT_RATIO, ONE);
-
               if (zeroForOne) {
                 !JSBI.greaterThan(sqrtPriceLimitX96, TickMath.MIN_SQRT_RATIO) ?  invariant(false, 'RATIO_MIN')  : void 0;
                 !JSBI.lessThan(sqrtPriceLimitX96, this.sqrtRatioX96) ?  invariant(false, 'RATIO_CURRENT')  : void 0;
@@ -2019,9 +1377,7 @@ var Pool = /*#__PURE__*/function () {
                 !JSBI.lessThan(sqrtPriceLimitX96, TickMath.MAX_SQRT_RATIO) ?  invariant(false, 'RATIO_MAX')  : void 0;
                 !JSBI.greaterThan(sqrtPriceLimitX96, this.sqrtRatioX96) ?  invariant(false, 'RATIO_CURRENT')  : void 0;
               }
-
               exactInput = JSBI.greaterThanOrEqual(amountSpecified, ZERO); // keep track of swap state
-
               state = {
                 amountSpecifiedRemaining: amountSpecified,
                 amountCalculated: ZERO,
@@ -2029,59 +1385,49 @@ var Pool = /*#__PURE__*/function () {
                 tick: this.tickCurrent,
                 liquidity: this.liquidity
               }; // start swap while loop
-
             case 4:
-              if (!(JSBI.notEqual(state.amountSpecifiedRemaining, ZERO) && state.sqrtPriceX96 != sqrtPriceLimitX96)) {
+              if (!(JSBI.notEqual(state.amountSpecifiedRemaining, ZERO) && state.sqrtPriceX96 !== sqrtPriceLimitX96)) {
                 _context3.next = 35;
                 break;
               }
-
               step = {};
               step.sqrtPriceStartX96 = state.sqrtPriceX96;
               _context3.next = 9;
               return this.tickDataProvider.nextInitializedTickWithinOneWord(state.tick, zeroForOne, this.tickSpacing);
-
             case 9:
               _yield$this$tickDataP = _context3.sent;
               step.tickNext = _yield$this$tickDataP[0];
               step.initialized = _yield$this$tickDataP[1];
-
               if (step.tickNext < TickMath.MIN_TICK) {
                 step.tickNext = TickMath.MIN_TICK;
               } else if (step.tickNext > TickMath.MAX_TICK) {
                 step.tickNext = TickMath.MAX_TICK;
               }
-
               step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
               _SwapMath$computeSwap = SwapMath.computeSwapStep(state.sqrtPriceX96, (zeroForOne ? JSBI.lessThan(step.sqrtPriceNextX96, sqrtPriceLimitX96) : JSBI.greaterThan(step.sqrtPriceNextX96, sqrtPriceLimitX96)) ? sqrtPriceLimitX96 : step.sqrtPriceNextX96, state.liquidity, state.amountSpecifiedRemaining, this.fee);
               state.sqrtPriceX96 = _SwapMath$computeSwap[0];
               step.amountIn = _SwapMath$computeSwap[1];
               step.amountOut = _SwapMath$computeSwap[2];
               step.feeAmount = _SwapMath$computeSwap[3];
-
               if (exactInput) {
                 state.amountSpecifiedRemaining = JSBI.subtract(state.amountSpecifiedRemaining, JSBI.add(step.amountIn, step.feeAmount));
                 state.amountCalculated = JSBI.subtract(state.amountCalculated, step.amountOut);
               } else {
                 state.amountSpecifiedRemaining = JSBI.add(state.amountSpecifiedRemaining, step.amountOut);
                 state.amountCalculated = JSBI.add(state.amountCalculated, JSBI.add(step.amountIn, step.feeAmount));
-              } // TODO
-
-
+              }
+              // TODO
               if (!JSBI.equal(state.sqrtPriceX96, step.sqrtPriceNextX96)) {
                 _context3.next = 32;
                 break;
               }
-
               if (!step.initialized) {
                 _context3.next = 29;
                 break;
               }
-
               _context3.t0 = JSBI;
               _context3.next = 25;
               return this.tickDataProvider.getTick(step.tickNext);
-
             case 25:
               _context3.t1 = _context3.sent.liquidityNet;
               liquidityNet = _context3.t0.BigInt.call(_context3.t0, _context3.t1);
@@ -2089,22 +1435,19 @@ var Pool = /*#__PURE__*/function () {
               // safe because liquidityNet cannot be type(int128).min
               if (zeroForOne) liquidityNet = JSBI.multiply(liquidityNet, NEGATIVE_ONE);
               state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
-
             case 29:
               state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
               _context3.next = 33;
               break;
-
             case 32:
-              if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
+              if (JSBI.notEqual(state.sqrtPriceX96, step.sqrtPriceStartX96)) {
+                // updated comparison function
                 // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
                 state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
               }
-
             case 33:
               _context3.next = 4;
               break;
-
             case 35:
               return _context3.abrupt("return", {
                 amountCalculated: state.amountCalculated,
@@ -2112,38 +1455,30 @@ var Pool = /*#__PURE__*/function () {
                 liquidity: state.liquidity,
                 tickCurrent: state.tick
               });
-
             case 36:
             case "end":
               return _context3.stop();
           }
-        }
-      }, _callee3, this);
-    }));
-
-    function swap(_x5, _x6, _x7) {
-      return _swap.apply(this, arguments);
-    }
-
-    return swap;
-  }();
-
+        }, _callee3, this);
+      }));
+      function swap(_x5, _x6, _x7) {
+        return _swap.apply(this, arguments);
+      }
+      return swap;
+    }();
   _createClass(Pool, [{
     key: "token0Price",
     get: function get() {
       var _this$_token0Price;
-
       return (_this$_token0Price = this._token0Price) != null ? _this$_token0Price : this._token0Price = new sdkCore.Price(this.token0, this.token1, Q192, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96));
     }
     /**
      * Returns the current mid price of the pool in terms of token1, i.e. the ratio of token0 over token1
      */
-
   }, {
     key: "token1Price",
     get: function get() {
       var _this$_token1Price;
-
       return (_this$_token1Price = this._token1Price) != null ? _this$_token1Price : this._token1Price = new sdkCore.Price(this.token1, this.token0, JSBI.multiply(this.sqrtRatioX96, this.sqrtRatioX96), Q192);
     }
   }, {
@@ -2157,14 +1492,12 @@ var Pool = /*#__PURE__*/function () {
       return TICK_SPACINGS[this.fee];
     }
   }]);
-
   return Pool;
 }();
 
 /**
  * Represents a position on a Uniswap V3 Pool
  */
-
 var Position = /*#__PURE__*/function () {
   /**
    * Constructs a position for a given pool with the given liquidity
@@ -2175,9 +1508,9 @@ var Position = /*#__PURE__*/function () {
    */
   function Position(_ref) {
     var pool = _ref.pool,
-        liquidity = _ref.liquidity,
-        tickLower = _ref.tickLower,
-        tickUpper = _ref.tickUpper;
+      liquidity = _ref.liquidity,
+      tickLower = _ref.tickLower,
+      tickUpper = _ref.tickUpper;
     // cached resuts for the getters
     this._token0Amount = null;
     this._token1Amount = null;
@@ -2193,10 +1526,7 @@ var Position = /*#__PURE__*/function () {
   /**
    * Returns the price of token0 at the lower tick
    */
-
-
   var _proto = Position.prototype;
-
   /**
    * Returns the lower and upper sqrt ratios if the price 'slips' up to slippage tolerance percentage
    * @param slippageTolerance The amount by which the price can 'slip' before the transaction will revert
@@ -2206,17 +1536,13 @@ var Position = /*#__PURE__*/function () {
     var priceLower = this.pool.token0Price.asFraction.multiply(new sdkCore.Percent(1).subtract(slippageTolerance));
     var priceUpper = this.pool.token0Price.asFraction.multiply(slippageTolerance.add(1));
     var sqrtRatioX96Lower = encodeSqrtRatioX96(priceLower.numerator, priceLower.denominator);
-
     if (JSBI.lessThanOrEqual(sqrtRatioX96Lower, TickMath.MIN_SQRT_RATIO)) {
       sqrtRatioX96Lower = JSBI.add(TickMath.MIN_SQRT_RATIO, JSBI.BigInt(1));
     }
-
     var sqrtRatioX96Upper = encodeSqrtRatioX96(priceUpper.numerator, priceUpper.denominator);
-
     if (JSBI.greaterThanOrEqual(sqrtRatioX96Upper, TickMath.MAX_SQRT_RATIO)) {
       sqrtRatioX96Upper = JSBI.subtract(TickMath.MAX_SQRT_RATIO, JSBI.BigInt(1));
     }
-
     return {
       sqrtRatioX96Lower: sqrtRatioX96Lower,
       sqrtRatioX96Upper: sqrtRatioX96Upper
@@ -2227,39 +1553,32 @@ var Position = /*#__PURE__*/function () {
    * with the given slippage tolerance
    * @param slippageTolerance Tolerance of unfavorable slippage from the current price
    * @returns The amounts, with slippage
-   */
-  ;
-
+   */;
   _proto.mintAmountsWithSlippage = function mintAmountsWithSlippage(slippageTolerance) {
     // get lower/upper prices
     var _this$ratiosAfterSlip = this.ratiosAfterSlippage(slippageTolerance),
-        sqrtRatioX96Upper = _this$ratiosAfterSlip.sqrtRatioX96Upper,
-        sqrtRatioX96Lower = _this$ratiosAfterSlip.sqrtRatioX96Lower; // construct counterfactual pools
-
-
-    var poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, 0
-    /* liquidity doesn't matter */
-    , TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower));
-    var poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, 0
-    /* liquidity doesn't matter */
-    , TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper)); // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)
-
+      sqrtRatioX96Upper = _this$ratiosAfterSlip.sqrtRatioX96Upper,
+      sqrtRatioX96Lower = _this$ratiosAfterSlip.sqrtRatioX96Lower;
+    // construct counterfactual pools
+    var poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower));
+    var poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper));
+    // because the router is imprecise, we need to calculate the position that will be created (assuming no slippage)
     var positionThatWillBeCreated = Position.fromAmounts(_extends({
       pool: this.pool,
       tickLower: this.tickLower,
       tickUpper: this.tickUpper
     }, this.mintAmounts, {
       useFullPrecision: false
-    })); // we want the smaller amounts...
+    }));
+    // we want the smaller amounts...
     // ...which occurs at the upper price for amount0...
-
     var amount0 = new Position({
       pool: poolUpper,
       liquidity: positionThatWillBeCreated.liquidity,
       tickLower: this.tickLower,
       tickUpper: this.tickUpper
-    }).mintAmounts.amount0; // ...and the lower for amount1
-
+    }).mintAmounts.amount0;
+    // ...and the lower for amount1
     var amount1 = new Position({
       pool: poolLower,
       liquidity: positionThatWillBeCreated.liquidity,
@@ -2276,31 +1595,24 @@ var Position = /*#__PURE__*/function () {
    * position with the given slippage tolerance
    * @param slippageTolerance tolerance of unfavorable slippage from the current price
    * @returns The amounts, with slippage
-   */
-  ;
-
+   */;
   _proto.burnAmountsWithSlippage = function burnAmountsWithSlippage(slippageTolerance) {
     // get lower/upper prices
     var _this$ratiosAfterSlip2 = this.ratiosAfterSlippage(slippageTolerance),
-        sqrtRatioX96Upper = _this$ratiosAfterSlip2.sqrtRatioX96Upper,
-        sqrtRatioX96Lower = _this$ratiosAfterSlip2.sqrtRatioX96Lower; // construct counterfactual pools
-
-
-    var poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, 0
-    /* liquidity doesn't matter */
-    , TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower));
-    var poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, 0
-    /* liquidity doesn't matter */
-    , TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper)); // we want the smaller amounts...
+      sqrtRatioX96Upper = _this$ratiosAfterSlip2.sqrtRatioX96Upper,
+      sqrtRatioX96Lower = _this$ratiosAfterSlip2.sqrtRatioX96Lower;
+    // construct counterfactual pools
+    var poolLower = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Lower, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Lower));
+    var poolUpper = new Pool(this.pool.token0, this.pool.token1, this.pool.fee, sqrtRatioX96Upper, 0 /* liquidity doesn't matter */, TickMath.getTickAtSqrtRatio(sqrtRatioX96Upper));
+    // we want the smaller amounts...
     // ...which occurs at the upper price for amount0...
-
     var amount0 = new Position({
       pool: poolUpper,
       liquidity: this.liquidity,
       tickLower: this.tickLower,
       tickUpper: this.tickUpper
-    }).amount0; // ...and the lower for amount1
-
+    }).amount0;
+    // ...and the lower for amount1
     var amount1 = new Position({
       pool: poolLower,
       liquidity: this.liquidity,
@@ -2315,9 +1627,7 @@ var Position = /*#__PURE__*/function () {
   /**
    * Returns the minimum amounts that must be sent in order to mint the amount of liquidity held by the position at
    * the current price for the pool
-   */
-  ;
-
+   */;
   /**
    * Computes the maximum amount of liquidity received for a given amount of token0, token1,
    * and the prices at the tick boundaries.
@@ -2332,11 +1642,11 @@ var Position = /*#__PURE__*/function () {
    */
   Position.fromAmounts = function fromAmounts(_ref2) {
     var pool = _ref2.pool,
-        tickLower = _ref2.tickLower,
-        tickUpper = _ref2.tickUpper,
-        amount0 = _ref2.amount0,
-        amount1 = _ref2.amount1,
-        useFullPrecision = _ref2.useFullPrecision;
+      tickLower = _ref2.tickLower,
+      tickUpper = _ref2.tickUpper,
+      amount0 = _ref2.amount0,
+      amount1 = _ref2.amount1,
+      useFullPrecision = _ref2.useFullPrecision;
     var sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);
     var sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
     return new Position({
@@ -2355,15 +1665,13 @@ var Position = /*#__PURE__*/function () {
    * @param useFullPrecision If true, liquidity will be maximized according to what the router can calculate,
    * not what core can theoretically support
    * @returns The position
-   */
-  ;
-
+   */;
   Position.fromAmount0 = function fromAmount0(_ref3) {
     var pool = _ref3.pool,
-        tickLower = _ref3.tickLower,
-        tickUpper = _ref3.tickUpper,
-        amount0 = _ref3.amount0,
-        useFullPrecision = _ref3.useFullPrecision;
+      tickLower = _ref3.tickLower,
+      tickUpper = _ref3.tickUpper,
+      amount0 = _ref3.amount0,
+      useFullPrecision = _ref3.useFullPrecision;
     return Position.fromAmounts({
       pool: pool,
       tickLower: tickLower,
@@ -2380,14 +1688,12 @@ var Position = /*#__PURE__*/function () {
    * @param tickUpper The upper tick
    * @param amount1 The desired amount of token1
    * @returns The position
-   */
-  ;
-
+   */;
   Position.fromAmount1 = function fromAmount1(_ref4) {
     var pool = _ref4.pool,
-        tickLower = _ref4.tickLower,
-        tickUpper = _ref4.tickUpper,
-        amount1 = _ref4.amount1;
+      tickLower = _ref4.tickLower,
+      tickUpper = _ref4.tickUpper,
+      amount1 = _ref4.amount1;
     // this function always uses full precision,
     return Position.fromAmounts({
       pool: pool,
@@ -2398,7 +1704,6 @@ var Position = /*#__PURE__*/function () {
       useFullPrecision: true
     });
   };
-
   _createClass(Position, [{
     key: "token0PriceLower",
     get: function get() {
@@ -2407,7 +1712,6 @@ var Position = /*#__PURE__*/function () {
     /**
      * Returns the price of token0 at the upper tick
      */
-
   }, {
     key: "token0PriceUpper",
     get: function get() {
@@ -2416,7 +1720,6 @@ var Position = /*#__PURE__*/function () {
     /**
      * Returns the amount of token0 that this position's liquidity could be burned for at the current pool price
      */
-
   }, {
     key: "amount0",
     get: function get() {
@@ -2429,13 +1732,11 @@ var Position = /*#__PURE__*/function () {
           this._token0Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token0, ZERO);
         }
       }
-
       return this._token0Amount;
     }
     /**
      * Returns the amount of token1 that this position's liquidity could be burned for at the current pool price
      */
-
   }, {
     key: "amount1",
     get: function get() {
@@ -2448,7 +1749,6 @@ var Position = /*#__PURE__*/function () {
           this._token1Amount = sdkCore.CurrencyAmount.fromRawAmount(this.pool.token1, SqrtPriceMath.getAmount1Delta(TickMath.getSqrtRatioAtTick(this.tickLower), TickMath.getSqrtRatioAtTick(this.tickUpper), this.liquidity, false));
         }
       }
-
       return this._token1Amount;
     }
   }, {
@@ -2472,11 +1772,9 @@ var Position = /*#__PURE__*/function () {
           };
         }
       }
-
       return this._mintAmounts;
     }
   }]);
-
   return Position;
 }();
 
@@ -2485,7 +1783,6 @@ var Position = /*#__PURE__*/function () {
  * @template TInput The input token
  * @template TOutput The output token
  */
-
 var Route = /*#__PURE__*/function () {
   /**
    * Creates an instance of route.
@@ -2507,25 +1804,21 @@ var Route = /*#__PURE__*/function () {
     /**
      * Normalizes token0-token1 order and selects the next token/fee step to add to the path
      * */
-
     var tokenPath = [wrappedInput];
-
     for (var _iterator = _createForOfIteratorHelperLoose(pools.entries()), _step; !(_step = _iterator()).done;) {
       var _step$value = _step.value,
-          i = _step$value[0],
-          pool = _step$value[1];
+        i = _step$value[0],
+        pool = _step$value[1];
       var currentInputToken = tokenPath[i];
       !(currentInputToken.equals(pool.token0) || currentInputToken.equals(pool.token1)) ?  invariant(false, 'PATH')  : void 0;
       var nextToken = currentInputToken.equals(pool.token0) ? pool.token1 : pool.token0;
       tokenPath.push(nextToken);
     }
-
     this.pools = pools;
     this.tokenPath = tokenPath;
     this.input = input;
     this.output = output != null ? output : tokenPath[tokenPath.length - 1];
   }
-
   _createClass(Route, [{
     key: "chainId",
     get: function get() {
@@ -2534,14 +1827,13 @@ var Route = /*#__PURE__*/function () {
     /**
      * Returns the mid price of the route
      */
-
   }, {
     key: "midPrice",
     get: function get() {
       if (this._midPrice !== null) return this._midPrice;
       var price = this.pools.slice(1).reduce(function (_ref, pool) {
         var nextInput = _ref.nextInput,
-            price = _ref.price;
+          price = _ref.price;
         return nextInput.equals(pool.token0) ? {
           nextInput: pool.token1,
           price: price.multiply(pool.token0Price)
@@ -2559,7 +1851,6 @@ var Route = /*#__PURE__*/function () {
       return this._midPrice = new sdkCore.Price(this.input, this.output, price.denominator, price.numerator);
     }
   }]);
-
   return Route;
 }();
 
@@ -2572,12 +1863,10 @@ var Route = /*#__PURE__*/function () {
  * @param b The second trade to compare
  * @returns A sorted ordering for two neighboring elements in a trade array
  */
-
 function tradeComparator(a, b) {
   // must have same input and output token for comparison
   !a.inputAmount.currency.equals(b.inputAmount.currency) ?  invariant(false, 'INPUT_CURRENCY')  : void 0;
   !a.outputAmount.currency.equals(b.outputAmount.currency) ?  invariant(false, 'OUTPUT_CURRENCY')  : void 0;
-
   if (a.outputAmount.equalTo(b.outputAmount)) {
     if (a.inputAmount.equalTo(b.inputAmount)) {
       // consider the number of hops since each hop costs gas
@@ -2588,9 +1877,8 @@ function tradeComparator(a, b) {
         return total + cur.route.tokenPath.length;
       }, 0);
       return aHops - bHops;
-    } // trade A requires less input than trade B, so A should come first
-
-
+    }
+    // trade A requires less input than trade B, so A should come first
     if (a.inputAmount.lessThan(b.inputAmount)) {
       return -1;
     } else {
@@ -2617,7 +1905,6 @@ function tradeComparator(a, b) {
  * @template TOutput The output token, either Ether or an ERC-20
  * @template TTradeType The trade type, either exact input or exact output
  */
-
 var Trade = /*#__PURE__*/function () {
   /**
    * Construct a trade by passing in the pre-computed property values
@@ -2626,7 +1913,7 @@ var Trade = /*#__PURE__*/function () {
    */
   function Trade(_ref) {
     var routes = _ref.routes,
-        tradeType = _ref.tradeType;
+      tradeType = _ref.tradeType;
     var inputCurrency = routes[0].inputAmount.currency;
     var outputCurrency = routes[0].outputAmount.currency;
     !routes.every(function (_ref2) {
@@ -2644,17 +1931,14 @@ var Trade = /*#__PURE__*/function () {
       return total + cur;
     }, 0);
     var poolAddressSet = new Set();
-
     for (var _iterator = _createForOfIteratorHelperLoose(routes), _step; !(_step = _iterator()).done;) {
       var route = _step.value.route;
-
       for (var _iterator2 = _createForOfIteratorHelperLoose(route.pools), _step2; !(_step2 = _iterator2()).done;) {
         var pool = _step2.value;
         poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee));
       }
     }
-
-    !(numPools == poolAddressSet.size) ?  invariant(false, 'POOLS_DUPLICATED')  : void 0;
+    !(numPools === poolAddressSet.size) ?  invariant(false, 'POOLS_DUPLICATED')  : void 0;
     this.swaps = routes;
     this.tradeType = tradeType;
   }
@@ -2665,8 +1949,6 @@ var Trade = /*#__PURE__*/function () {
    * When the trade consists of just a single route, this returns the route of the trade,
    * i.e. which pools the trade goes through.
    */
-
-
   /**
    * Constructs an exact in trade with the given amount in and route
    * @template TInput The input token, either Ether or an ERC-20
@@ -2676,29 +1958,24 @@ var Trade = /*#__PURE__*/function () {
    * @returns The exact in trade
    */
   Trade.exactIn =
-  /*#__PURE__*/
-  function () {
-    var _exactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(route, amountIn) {
-      return runtime_1.wrap(function _callee$(_context) {
-        while (1) {
-          switch (_context.prev = _context.next) {
+    /*#__PURE__*/
+    function () {
+      var _exactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(route, amountIn) {
+        return _regeneratorRuntime().wrap(function _callee$(_context) {
+          while (1) switch (_context.prev = _context.next) {
             case 0:
               return _context.abrupt("return", Trade.fromRoute(route, amountIn, sdkCore.TradeType.EXACT_INPUT));
-
             case 1:
             case "end":
               return _context.stop();
           }
-        }
-      }, _callee);
-    }));
-
-    function exactIn(_x, _x2) {
-      return _exactIn.apply(this, arguments);
-    }
-
-    return exactIn;
-  }()
+        }, _callee);
+      }));
+      function exactIn(_x, _x2) {
+        return _exactIn.apply(this, arguments);
+      }
+      return exactIn;
+    }()
   /**
    * Constructs an exact out trade with the given amount out and route
    * @template TInput The input token, either Ether or an ERC-20
@@ -2708,31 +1985,25 @@ var Trade = /*#__PURE__*/function () {
    * @returns The exact out trade
    */
   ;
-
   Trade.exactOut =
-  /*#__PURE__*/
-  function () {
-    var _exactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(route, amountOut) {
-      return runtime_1.wrap(function _callee2$(_context2) {
-        while (1) {
-          switch (_context2.prev = _context2.next) {
+    /*#__PURE__*/
+    function () {
+      var _exactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(route, amountOut) {
+        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
+          while (1) switch (_context2.prev = _context2.next) {
             case 0:
               return _context2.abrupt("return", Trade.fromRoute(route, amountOut, sdkCore.TradeType.EXACT_OUTPUT));
-
             case 1:
             case "end":
               return _context2.stop();
           }
-        }
-      }, _callee2);
-    }));
-
-    function exactOut(_x3, _x4) {
-      return _exactOut.apply(this, arguments);
-    }
-
-    return exactOut;
-  }()
+        }, _callee2);
+      }));
+      function exactOut(_x3, _x4) {
+        return _exactOut.apply(this, arguments);
+      }
+      return exactOut;
+    }()
   /**
    * Constructs a trade by simulating swaps through the given route
    * @template TInput The input token, either Ether or an ERC-20.
@@ -2744,83 +2015,66 @@ var Trade = /*#__PURE__*/function () {
    * @returns The route
    */
   ;
-
   Trade.fromRoute =
-  /*#__PURE__*/
-  function () {
-    var _fromRoute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(route, amount, tradeType) {
-      var amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput, _outputAmount, _i, _pool, _yield$_pool$getInput, _inputAmount;
-
-      return runtime_1.wrap(function _callee3$(_context3) {
-        while (1) {
-          switch (_context3.prev = _context3.next) {
+    /*#__PURE__*/
+    function () {
+      var _fromRoute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(route, amount, tradeType) {
+        var amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput, _outputAmount, _i, _pool, _yield$_pool$getInput, _inputAmount;
+        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
+          while (1) switch (_context3.prev = _context3.next) {
             case 0:
               amounts = new Array(route.tokenPath.length);
-
               if (!(tradeType === sdkCore.TradeType.EXACT_INPUT)) {
                 _context3.next = 19;
                 break;
               }
-
               !amount.currency.equals(route.input) ?  invariant(false, 'INPUT')  : void 0;
               amounts[0] = amount.wrapped;
               i = 0;
-
             case 5:
               if (!(i < route.tokenPath.length - 1)) {
                 _context3.next = 15;
                 break;
               }
-
               pool = route.pools[i];
               _context3.next = 9;
               return pool.getOutputAmount(amounts[i]);
-
             case 9:
               _yield$pool$getOutput = _context3.sent;
               _outputAmount = _yield$pool$getOutput[0];
               amounts[i + 1] = _outputAmount;
-
             case 12:
               i++;
               _context3.next = 5;
               break;
-
             case 15:
               inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
               outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
               _context3.next = 34;
               break;
-
             case 19:
               !amount.currency.equals(route.output) ?  invariant(false, 'OUTPUT')  : void 0;
               amounts[amounts.length - 1] = amount.wrapped;
               _i = route.tokenPath.length - 1;
-
             case 22:
               if (!(_i > 0)) {
                 _context3.next = 32;
                 break;
               }
-
               _pool = route.pools[_i - 1];
               _context3.next = 26;
               return _pool.getInputAmount(amounts[_i]);
-
             case 26:
               _yield$_pool$getInput = _context3.sent;
               _inputAmount = _yield$_pool$getInput[0];
               amounts[_i - 1] = _inputAmount;
-
             case 29:
               _i--;
               _context3.next = 22;
               break;
-
             case 32:
               inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
               outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
-
             case 34:
               return _context3.abrupt("return", new Trade({
                 routes: [{
@@ -2830,21 +2084,17 @@ var Trade = /*#__PURE__*/function () {
                 }],
                 tradeType: tradeType
               }));
-
             case 35:
             case "end":
               return _context3.stop();
           }
-        }
-      }, _callee3);
-    }));
-
-    function fromRoute(_x5, _x6, _x7) {
-      return _fromRoute.apply(this, arguments);
-    }
-
-    return fromRoute;
-  }()
+        }, _callee3);
+      }));
+      function fromRoute(_x5, _x6, _x7) {
+        return _fromRoute.apply(this, arguments);
+      }
+      return fromRoute;
+    }()
   /**
    * Constructs a trade from routes by simulating swaps
    *
@@ -2856,126 +2106,101 @@ var Trade = /*#__PURE__*/function () {
    * @returns The trade
    */
   ;
-
   Trade.fromRoutes =
-  /*#__PURE__*/
-  function () {
-    var _fromRoutes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(routes, tradeType) {
-      var populatedRoutes, _iterator3, _step3, _step3$value, route, amount, amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput2, _outputAmount2, _i2, _pool2, _yield$_pool2$getInpu, _inputAmount2;
-
-      return runtime_1.wrap(function _callee4$(_context4) {
-        while (1) {
-          switch (_context4.prev = _context4.next) {
+    /*#__PURE__*/
+    function () {
+      var _fromRoutes = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(routes, tradeType) {
+        var populatedRoutes, _iterator3, _step3, _step3$value, route, amount, amounts, inputAmount, outputAmount, i, pool, _yield$pool$getOutput2, _outputAmount2, _i2, _pool2, _yield$_pool2$getInpu, _inputAmount2;
+        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
+          while (1) switch (_context4.prev = _context4.next) {
             case 0:
               populatedRoutes = [];
               _iterator3 = _createForOfIteratorHelperLoose(routes);
-
             case 2:
               if ((_step3 = _iterator3()).done) {
                 _context4.next = 43;
                 break;
               }
-
               _step3$value = _step3.value, route = _step3$value.route, amount = _step3$value.amount;
               amounts = new Array(route.tokenPath.length);
               inputAmount = void 0;
               outputAmount = void 0;
-
               if (!(tradeType === sdkCore.TradeType.EXACT_INPUT)) {
                 _context4.next = 25;
                 break;
               }
-
               !amount.currency.equals(route.input) ?  invariant(false, 'INPUT')  : void 0;
               inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);
               amounts[0] = sdkCore.CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator);
               i = 0;
-
             case 12:
               if (!(i < route.tokenPath.length - 1)) {
                 _context4.next = 22;
                 break;
               }
-
               pool = route.pools[i];
               _context4.next = 16;
               return pool.getOutputAmount(amounts[i]);
-
             case 16:
               _yield$pool$getOutput2 = _context4.sent;
               _outputAmount2 = _yield$pool$getOutput2[0];
               amounts[i + 1] = _outputAmount2;
-
             case 19:
               i++;
               _context4.next = 12;
               break;
-
             case 22:
               outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);
               _context4.next = 40;
               break;
-
             case 25:
               !amount.currency.equals(route.output) ?  invariant(false, 'OUTPUT')  : void 0;
               outputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);
               amounts[amounts.length - 1] = sdkCore.CurrencyAmount.fromFractionalAmount(route.output.wrapped, amount.numerator, amount.denominator);
               _i2 = route.tokenPath.length - 1;
-
             case 29:
               if (!(_i2 > 0)) {
                 _context4.next = 39;
                 break;
               }
-
               _pool2 = route.pools[_i2 - 1];
               _context4.next = 33;
               return _pool2.getInputAmount(amounts[_i2]);
-
             case 33:
               _yield$_pool2$getInpu = _context4.sent;
               _inputAmount2 = _yield$_pool2$getInpu[0];
               amounts[_i2 - 1] = _inputAmount2;
-
             case 36:
               _i2--;
               _context4.next = 29;
               break;
-
             case 39:
               inputAmount = sdkCore.CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);
-
             case 40:
               populatedRoutes.push({
                 route: route,
                 inputAmount: inputAmount,
                 outputAmount: outputAmount
               });
-
             case 41:
               _context4.next = 2;
               break;
-
             case 43:
               return _context4.abrupt("return", new Trade({
                 routes: populatedRoutes,
                 tradeType: tradeType
               }));
-
             case 44:
             case "end":
               return _context4.stop();
           }
-        }
-      }, _callee4);
-    }));
-
-    function fromRoutes(_x8, _x9) {
-      return _fromRoutes.apply(this, arguments);
-    }
-
-    return fromRoutes;
-  }()
+        }, _callee4);
+      }));
+      function fromRoutes(_x8, _x9) {
+        return _fromRoutes.apply(this, arguments);
+      }
+      return fromRoutes;
+    }()
   /**
    * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade
    * elsewhere and do not have any tick data
@@ -2986,7 +2211,6 @@ var Trade = /*#__PURE__*/function () {
    * @returns The unchecked trade
    */
   ;
-
   Trade.createUncheckedTrade = function createUncheckedTrade(constructorArguments) {
     return new Trade(_extends({}, constructorArguments, {
       routes: [{
@@ -3004,9 +2228,7 @@ var Trade = /*#__PURE__*/function () {
    * @template TTradeType The type of the trade, either exact in or exact out
    * @param constructorArguments The arguments passed to the trade constructor
    * @returns The unchecked trade
-   */
-  ;
-
+   */;
   Trade.createUncheckedTradeWithMultipleRoutes = function createUncheckedTradeWithMultipleRoutes(constructorArguments) {
     return new Trade(constructorArguments);
   }
@@ -3014,18 +2236,13 @@ var Trade = /*#__PURE__*/function () {
    * Get the minimum amount that must be received from this trade for the given slippage tolerance
    * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade
    * @returns The amount out
-   */
-  ;
-
+   */;
   var _proto = Trade.prototype;
-
   _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance, amountOut) {
     if (amountOut === void 0) {
       amountOut = this.outputAmount;
     }
-
     !!slippageTolerance.lessThan(ZERO) ?  invariant(false, 'SLIPPAGE_TOLERANCE')  : void 0;
-
     if (this.tradeType === sdkCore.TradeType.EXACT_OUTPUT) {
       return amountOut;
     } else {
@@ -3037,16 +2254,12 @@ var Trade = /*#__PURE__*/function () {
    * Get the maximum amount in that can be spent via this trade for the given slippage tolerance
    * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade
    * @returns The amount in
-   */
-  ;
-
+   */;
   _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance, amountIn) {
     if (amountIn === void 0) {
       amountIn = this.inputAmount;
     }
-
     !!slippageTolerance.lessThan(ZERO) ?  invariant(false, 'SLIPPAGE_TOLERANCE')  : void 0;
-
     if (this.tradeType === sdkCore.TradeType.EXACT_INPUT) {
       return amountIn;
     } else {
@@ -3058,9 +2271,7 @@ var Trade = /*#__PURE__*/function () {
    * Return the execution price after accounting for slippage tolerance
    * @param slippageTolerance the allowed tolerated slippage
    * @returns The execution price
-   */
-  ;
-
+   */;
   _proto.worstExecutionPrice = function worstExecutionPrice(slippageTolerance) {
     return new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);
   }
@@ -3078,93 +2289,73 @@ var Trade = /*#__PURE__*/function () {
    * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter
    * @param bestTrades used in recursion; the current list of best trades
    * @returns The exact in trade
-   */
-  ;
-
+   */;
   Trade.bestTradeExactIn =
-  /*#__PURE__*/
-  function () {
-    var _bestTradeExactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(pools, currencyAmountIn, currencyOut, _temp, // used in recursion.
-    currentPools, nextAmountIn, bestTrades) {
-      var _ref5, _ref5$maxNumResults, maxNumResults, _ref5$maxHops, maxHops, amountIn, tokenOut, i, pool, amountOut, _yield$pool$getOutput3, poolsExcludingThisPool;
-
-      return runtime_1.wrap(function _callee5$(_context5) {
-        while (1) {
-          switch (_context5.prev = _context5.next) {
+    /*#__PURE__*/
+    function () {
+      var _bestTradeExactIn = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(pools, currencyAmountIn, currencyOut, _temp,
+                                                                                                                        // used in recursion.
+                                                                                                                        currentPools, nextAmountIn, bestTrades) {
+        var _ref5, _ref5$maxNumResults, maxNumResults, _ref5$maxHops, maxHops, amountIn, tokenOut, i, pool, amountOut, _yield$pool$getOutput3, poolsExcludingThisPool;
+        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
+          while (1) switch (_context5.prev = _context5.next) {
             case 0:
               _ref5 = _temp === void 0 ? {} : _temp, _ref5$maxNumResults = _ref5.maxNumResults, maxNumResults = _ref5$maxNumResults === void 0 ? 3 : _ref5$maxNumResults, _ref5$maxHops = _ref5.maxHops, maxHops = _ref5$maxHops === void 0 ? 3 : _ref5$maxHops;
-
               if (currentPools === void 0) {
                 currentPools = [];
               }
-
               if (nextAmountIn === void 0) {
                 nextAmountIn = currencyAmountIn;
               }
-
               if (bestTrades === void 0) {
                 bestTrades = [];
               }
-
               !(pools.length > 0) ?  invariant(false, 'POOLS')  : void 0;
               !(maxHops > 0) ?  invariant(false, 'MAX_HOPS')  : void 0;
               !(currencyAmountIn === nextAmountIn || currentPools.length > 0) ?  invariant(false, 'INVALID_RECURSION')  : void 0;
               amountIn = nextAmountIn.wrapped;
               tokenOut = currencyOut.wrapped;
               i = 0;
-
             case 10:
               if (!(i < pools.length)) {
                 _context5.next = 46;
                 break;
               }
-
               pool = pools[i]; // pool irrelevant
-
               if (!(!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency))) {
                 _context5.next = 14;
                 break;
               }
-
               return _context5.abrupt("continue", 43);
-
             case 14:
               amountOut = void 0;
               _context5.prev = 15;
               _context5.next = 19;
               return pool.getOutputAmount(amountIn);
-
             case 19:
               _yield$pool$getOutput3 = _context5.sent;
               amountOut = _yield$pool$getOutput3[0];
               _context5.next = 28;
               break;
-
             case 23:
               _context5.prev = 23;
               _context5.t0 = _context5["catch"](15);
-
               if (!_context5.t0.isInsufficientInputAmountError) {
                 _context5.next = 27;
                 break;
               }
-
               return _context5.abrupt("continue", 43);
-
             case 27:
               throw _context5.t0;
-
             case 28:
               if (!(amountOut.currency.isToken && amountOut.currency.equals(tokenOut))) {
                 _context5.next = 39;
                 break;
               }
-
               _context5.t1 = sdkCore.sortedInsert;
               _context5.t2 = bestTrades;
               _context5.next = 33;
               return Trade.fromRoute(new Route([].concat(currentPools, [pool]), currencyAmountIn.currency, currencyOut), currencyAmountIn, sdkCore.TradeType.EXACT_INPUT);
-
             case 33:
               _context5.t3 = _context5.sent;
               _context5.t4 = maxNumResults;
@@ -3172,43 +2363,34 @@ var Trade = /*#__PURE__*/function () {
               (0, _context5.t1)(_context5.t2, _context5.t3, _context5.t4, _context5.t5);
               _context5.next = 43;
               break;
-
             case 39:
               if (!(maxHops > 1 && pools.length > 1)) {
                 _context5.next = 43;
                 break;
               }
-
               poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops
-
               _context5.next = 43;
               return Trade.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {
                 maxNumResults: maxNumResults,
                 maxHops: maxHops - 1
               }, [].concat(currentPools, [pool]), amountOut, bestTrades);
-
             case 43:
               i++;
               _context5.next = 10;
               break;
-
             case 46:
               return _context5.abrupt("return", bestTrades);
-
             case 47:
             case "end":
               return _context5.stop();
           }
-        }
-      }, _callee5, null, [[15, 23]]);
-    }));
-
-    function bestTradeExactIn(_x10, _x11, _x12, _x13, _x14, _x15, _x16) {
-      return _bestTradeExactIn.apply(this, arguments);
-    }
-
-    return bestTradeExactIn;
-  }()
+        }, _callee5, null, [[15, 23]]);
+      }));
+      function bestTradeExactIn(_x10, _x11, _x12, _x13, _x14, _x15, _x16) {
+        return _bestTradeExactIn.apply(this, arguments);
+      }
+      return bestTradeExactIn;
+    }()
   /**
    * similar to the above method but instead targets a fixed output amount
    * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token
@@ -3226,91 +2408,72 @@ var Trade = /*#__PURE__*/function () {
    * @returns The exact out trade
    */
   ;
-
   Trade.bestTradeExactOut =
-  /*#__PURE__*/
-  function () {
-    var _bestTradeExactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(pools, currencyIn, currencyAmountOut, _temp2, // used in recursion.
-    currentPools, nextAmountOut, bestTrades) {
-      var _ref6, _ref6$maxNumResults, maxNumResults, _ref6$maxHops, maxHops, amountOut, tokenIn, i, pool, amountIn, _yield$pool$getInputA, poolsExcludingThisPool;
-
-      return runtime_1.wrap(function _callee6$(_context6) {
-        while (1) {
-          switch (_context6.prev = _context6.next) {
+    /*#__PURE__*/
+    function () {
+      var _bestTradeExactOut = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(pools, currencyIn, currencyAmountOut, _temp2,
+                                                                                                                         // used in recursion.
+                                                                                                                         currentPools, nextAmountOut, bestTrades) {
+        var _ref6, _ref6$maxNumResults, maxNumResults, _ref6$maxHops, maxHops, amountOut, tokenIn, i, pool, amountIn, _yield$pool$getInputA, poolsExcludingThisPool;
+        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
+          while (1) switch (_context6.prev = _context6.next) {
             case 0:
               _ref6 = _temp2 === void 0 ? {} : _temp2, _ref6$maxNumResults = _ref6.maxNumResults, maxNumResults = _ref6$maxNumResults === void 0 ? 3 : _ref6$maxNumResults, _ref6$maxHops = _ref6.maxHops, maxHops = _ref6$maxHops === void 0 ? 3 : _ref6$maxHops;
-
               if (currentPools === void 0) {
                 currentPools = [];
               }
-
               if (nextAmountOut === void 0) {
                 nextAmountOut = currencyAmountOut;
               }
-
               if (bestTrades === void 0) {
                 bestTrades = [];
               }
-
               !(pools.length > 0) ?  invariant(false, 'POOLS')  : void 0;
               !(maxHops > 0) ?  invariant(false, 'MAX_HOPS')  : void 0;
               !(currencyAmountOut === nextAmountOut || currentPools.length > 0) ?  invariant(false, 'INVALID_RECURSION')  : void 0;
               amountOut = nextAmountOut.wrapped;
               tokenIn = currencyIn.wrapped;
               i = 0;
-
             case 10:
               if (!(i < pools.length)) {
                 _context6.next = 46;
                 break;
               }
-
               pool = pools[i]; // pool irrelevant
-
               if (!(!pool.token0.equals(amountOut.currency) && !pool.token1.equals(amountOut.currency))) {
                 _context6.next = 14;
                 break;
               }
-
               return _context6.abrupt("continue", 43);
-
             case 14:
               amountIn = void 0;
               _context6.prev = 15;
               _context6.next = 19;
               return pool.getInputAmount(amountOut);
-
             case 19:
               _yield$pool$getInputA = _context6.sent;
               amountIn = _yield$pool$getInputA[0];
               _context6.next = 28;
               break;
-
             case 23:
               _context6.prev = 23;
               _context6.t0 = _context6["catch"](15);
-
               if (!_context6.t0.isInsufficientReservesError) {
                 _context6.next = 27;
                 break;
               }
-
               return _context6.abrupt("continue", 43);
-
             case 27:
               throw _context6.t0;
-
             case 28:
               if (!amountIn.currency.equals(tokenIn)) {
                 _context6.next = 39;
                 break;
               }
-
               _context6.t1 = sdkCore.sortedInsert;
               _context6.t2 = bestTrades;
               _context6.next = 33;
               return Trade.fromRoute(new Route([pool].concat(currentPools), currencyIn, currencyAmountOut.currency), currencyAmountOut, sdkCore.TradeType.EXACT_OUTPUT);
-
             case 33:
               _context6.t3 = _context6.sent;
               _context6.t4 = maxNumResults;
@@ -3318,61 +2481,49 @@ var Trade = /*#__PURE__*/function () {
               (0, _context6.t1)(_context6.t2, _context6.t3, _context6.t4, _context6.t5);
               _context6.next = 43;
               break;
-
             case 39:
               if (!(maxHops > 1 && pools.length > 1)) {
                 _context6.next = 43;
                 break;
               }
-
               poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length)); // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops
-
               _context6.next = 43;
               return Trade.bestTradeExactOut(poolsExcludingThisPool, currencyIn, currencyAmountOut, {
                 maxNumResults: maxNumResults,
                 maxHops: maxHops - 1
               }, [pool].concat(currentPools), amountIn, bestTrades);
-
             case 43:
               i++;
               _context6.next = 10;
               break;
-
             case 46:
               return _context6.abrupt("return", bestTrades);
-
             case 47:
             case "end":
               return _context6.stop();
           }
-        }
-      }, _callee6, null, [[15, 23]]);
-    }));
-
-    function bestTradeExactOut(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {
-      return _bestTradeExactOut.apply(this, arguments);
-    }
-
-    return bestTradeExactOut;
-  }();
-
+        }, _callee6, null, [[15, 23]]);
+      }));
+      function bestTradeExactOut(_x17, _x18, _x19, _x20, _x21, _x22, _x23) {
+        return _bestTradeExactOut.apply(this, arguments);
+      }
+      return bestTradeExactOut;
+    }();
   _createClass(Trade, [{
     key: "route",
     get: function get() {
-      !(this.swaps.length == 1) ?  invariant(false, 'MULTIPLE_ROUTES')  : void 0;
+      !(this.swaps.length === 1) ?  invariant(false, 'MULTIPLE_ROUTES')  : void 0;
       return this.swaps[0].route;
     }
     /**
      * The input amount for the trade assuming no slippage.
      */
-
   }, {
     key: "inputAmount",
     get: function get() {
       if (this._inputAmount) {
         return this._inputAmount;
       }
-
       var inputCurrency = this.swaps[0].inputAmount.currency;
       var totalInputFromRoutes = this.swaps.map(function (_ref7) {
         var inputAmount = _ref7.inputAmount;
@@ -3386,14 +2537,12 @@ var Trade = /*#__PURE__*/function () {
     /**
      * The output amount for the trade assuming no slippage.
      */
-
   }, {
     key: "outputAmount",
     get: function get() {
       if (this._outputAmount) {
         return this._outputAmount;
       }
-
       var outputCurrency = this.swaps[0].outputAmount.currency;
       var totalOutputFromRoutes = this.swaps.map(function (_ref8) {
         var outputAmount = _ref8.outputAmount;
@@ -3407,41 +2556,34 @@ var Trade = /*#__PURE__*/function () {
     /**
      * The price expressed in terms of output amount/input amount.
      */
-
   }, {
     key: "executionPrice",
     get: function get() {
       var _this$_executionPrice;
-
       return (_this$_executionPrice = this._executionPrice) != null ? _this$_executionPrice : this._executionPrice = new sdkCore.Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);
     }
     /**
      * Returns the percent difference between the route's mid price and the price impact
      */
-
   }, {
     key: "priceImpact",
     get: function get() {
       if (this._priceImpact) {
         return this._priceImpact;
       }
-
       var spotOutputAmount = sdkCore.CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0);
-
       for (var _iterator4 = _createForOfIteratorHelperLoose(this.swaps), _step4; !(_step4 = _iterator4()).done;) {
         var _step4$value = _step4.value,
-            route = _step4$value.route,
-            inputAmount = _step4$value.inputAmount;
+          route = _step4$value.route,
+          inputAmount = _step4$value.inputAmount;
         var midPrice = route.midPrice;
         spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));
       }
-
       var priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);
       this._priceImpact = new sdkCore.Percent(priceImpact.numerator, priceImpact.denominator);
       return this._priceImpact;
     }
   }]);
-
   return Trade;
 }();
 
@@ -3450,15 +2592,12 @@ var Multicall = /*#__PURE__*/function () {
    * Cannot be constructed.
    */
   function Multicall() {}
-
   Multicall.encodeMulticall = function encodeMulticall(calldatas) {
     if (!Array.isArray(calldatas)) {
       calldatas = [calldatas];
     }
-
     return calldatas.length === 1 ? calldatas[0] : Multicall.INTERFACE.encodeFunctionData('multicall', [calldatas]);
   };
-
   return Multicall;
 }();
 Multicall.INTERFACE = /*#__PURE__*/new abi.Interface(IMulticall.abi);
@@ -3466,17 +2605,14 @@ Multicall.INTERFACE = /*#__PURE__*/new abi.Interface(IMulticall.abi);
 function isAllowedPermit(permitOptions) {
   return 'nonce' in permitOptions;
 }
-
 var SelfPermit = /*#__PURE__*/function () {
   /**
    * Cannot be constructed.
    */
   function SelfPermit() {}
-
   SelfPermit.encodePermit = function encodePermit(token, options) {
     return isAllowedPermit(options) ? SelfPermit.INTERFACE.encodeFunctionData('selfPermitAllowed', [token.address, toHex(options.nonce), toHex(options.expiry), options.v, options.r, options.s]) : SelfPermit.INTERFACE.encodeFunctionData('selfPermit', [token.address, toHex(options.amount), toHex(options.deadline), options.v, options.r, options.s]);
   };
-
   return SelfPermit;
 }();
 SelfPermit.INTERFACE = /*#__PURE__*/new abi.Interface(ISelfPermit.abi);
@@ -3486,14 +2622,11 @@ var Payments = /*#__PURE__*/function () {
    * Cannot be constructed.
    */
   function Payments() {}
-
   Payments.encodeFeeBips = function encodeFeeBips(fee) {
     return toHex(fee.multiply(10000).quotient);
   };
-
   Payments.encodeUnwrapWETH9 = function encodeUnwrapWETH9(amountMinimum, recipient, feeOptions) {
     recipient = sdkCore.validateAndParseAddress(recipient);
-
     if (!!feeOptions) {
       var feeBips = this.encodeFeeBips(feeOptions.fee);
       var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient);
@@ -3502,10 +2635,8 @@ var Payments = /*#__PURE__*/function () {
       return Payments.INTERFACE.encodeFunctionData('unwrapWETH9', [toHex(amountMinimum), recipient]);
     }
   };
-
   Payments.encodeSweepToken = function encodeSweepToken(token, amountMinimum, recipient, feeOptions) {
     recipient = sdkCore.validateAndParseAddress(recipient);
-
     if (!!feeOptions) {
       var feeBips = this.encodeFeeBips(feeOptions.fee);
       var feeRecipient = sdkCore.validateAndParseAddress(feeOptions.recipient);
@@ -3514,67 +2645,61 @@ var Payments = /*#__PURE__*/function () {
       return Payments.INTERFACE.encodeFunctionData('sweepToken', [token.address, toHex(amountMinimum), recipient]);
     }
   };
-
   Payments.encodeRefundETH = function encodeRefundETH() {
     return Payments.INTERFACE.encodeFunctionData('refundETH');
   };
-
   return Payments;
 }();
 Payments.INTERFACE = /*#__PURE__*/new abi.Interface(IPeripheryPaymentsWithFee.abi);
 
-var MaxUint128 = /*#__PURE__*/toHex( /*#__PURE__*/JSBI.subtract( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(128)), /*#__PURE__*/JSBI.BigInt(1))); // type guard
-
+var _excluded = ["expectedCurrencyOwed0", "expectedCurrencyOwed1"];
+var MaxUint128 = /*#__PURE__*/toHex( /*#__PURE__*/JSBI.subtract( /*#__PURE__*/JSBI.exponentiate( /*#__PURE__*/JSBI.BigInt(2), /*#__PURE__*/JSBI.BigInt(128)), /*#__PURE__*/JSBI.BigInt(1)));
+// type guard
 function isMint(options) {
   return Object.keys(options).some(function (k) {
     return k === 'recipient';
   });
 }
-
 var NonfungiblePositionManager = /*#__PURE__*/function () {
   /**
    * Cannot be constructed.
    */
   function NonfungiblePositionManager() {}
-
   NonfungiblePositionManager.encodeCreate = function encodeCreate(pool) {
     return NonfungiblePositionManager.INTERFACE.encodeFunctionData('createAndInitializePoolIfNecessary', [pool.token0.address, pool.token1.address, pool.fee, toHex(pool.sqrtRatioX96)]);
   };
-
   NonfungiblePositionManager.createCallParameters = function createCallParameters(pool) {
     return {
       calldata: this.encodeCreate(pool),
       value: toHex(0)
     };
   };
-
   NonfungiblePositionManager.addCallParameters = function addCallParameters(position, options) {
     !JSBI.greaterThan(position.liquidity, ZERO) ?  invariant(false, 'ZERO_LIQUIDITY')  : void 0;
-    var calldatas = []; // get amounts
-
+    var calldatas = [];
+    var value = toHex(0);
+    // get amounts
     var _position$mintAmounts = position.mintAmounts,
-        amount0Desired = _position$mintAmounts.amount0,
-        amount1Desired = _position$mintAmounts.amount1; // adjust for slippage
-
+      amount0Desired = _position$mintAmounts.amount0,
+      amount1Desired = _position$mintAmounts.amount1;
+    // adjust for slippage
     var minimumAmounts = position.mintAmountsWithSlippage(options.slippageTolerance);
     var amount0Min = toHex(minimumAmounts.amount0);
     var amount1Min = toHex(minimumAmounts.amount1);
-    var deadline = toHex(options.deadline); // create pool if needed
-
+    var deadline = toHex(options.deadline);
+    // create pool if needed
     if (isMint(options) && options.createPool) {
       calldatas.push(this.encodeCreate(position.pool));
-    } // permits if necessary
-
-
+      value = JSBI.BigInt("1024000000000000000000").toString(16);
+    }
+    // permits if necessary
     if (options.token0Permit) {
       calldatas.push(SelfPermit.encodePermit(position.pool.token0, options.token0Permit));
     }
-
     if (options.token1Permit) {
       calldatas.push(SelfPermit.encodePermit(position.pool.token1, options.token1Permit));
-    } // mint
-
-
+    }
+    // mint
     if (isMint(options)) {
       var recipient = sdkCore.validateAndParseAddress(options.recipient);
       calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('mint', [{
@@ -3601,40 +2726,33 @@ var NonfungiblePositionManager = /*#__PURE__*/function () {
         deadline: deadline
       }]));
     }
-
-    var value = toHex(0);
-
     if (options.useNative) {
       var wrapped = options.useNative.wrapped;
       !(position.pool.token0.equals(wrapped) || position.pool.token1.equals(wrapped)) ?  invariant(false, 'NO_WETH')  : void 0;
-      var wrappedValue = position.pool.token0.equals(wrapped) ? amount0Desired : amount1Desired; // we only need to refund if we're actually sending ETH
-
+      var wrappedValue = position.pool.token0.equals(wrapped) ? amount0Desired : amount1Desired;
+      // we only need to refund if we're actually sending ETH
       if (JSBI.greaterThan(wrappedValue, ZERO)) {
         calldatas.push(Payments.encodeRefundETH());
       }
-
       value = toHex(wrappedValue);
     }
-
     return {
       calldata: Multicall.encodeMulticall(calldatas),
       value: value
     };
   };
-
   NonfungiblePositionManager.encodeCollect = function encodeCollect(options) {
     var calldatas = [];
     var tokenId = toHex(options.tokenId);
     var involvesETH = options.expectedCurrencyOwed0.currency.isNative || options.expectedCurrencyOwed1.currency.isNative;
-    var recipient = sdkCore.validateAndParseAddress(options.recipient); // collect
-
+    var recipient = sdkCore.validateAndParseAddress(options.recipient);
+    // collect
     calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('collect', [{
       tokenId: tokenId,
       recipient: involvesETH ? ADDRESS_ZERO : recipient,
       amount0Max: MaxUint128,
       amount1Max: MaxUint128
     }]));
-
     if (involvesETH) {
       var ethAmount = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed0.quotient : options.expectedCurrencyOwed1.quotient;
       var token = options.expectedCurrencyOwed0.currency.isNative ? options.expectedCurrencyOwed1.currency : options.expectedCurrencyOwed0.currency;
@@ -3642,10 +2760,8 @@ var NonfungiblePositionManager = /*#__PURE__*/function () {
       calldatas.push(Payments.encodeUnwrapWETH9(ethAmount, recipient));
       calldatas.push(Payments.encodeSweepToken(token, tokenAmount, recipient));
     }
-
     return calldatas;
   };
-
   NonfungiblePositionManager.collectCallParameters = function collectCallParameters(options) {
     var calldatas = NonfungiblePositionManager.encodeCollect(options);
     return {
@@ -3658,31 +2774,27 @@ var NonfungiblePositionManager = /*#__PURE__*/function () {
    * @param position The position to exit
    * @param options Additional information necessary for generating the calldata
    * @returns The call parameters
-   */
-  ;
-
+   */;
   NonfungiblePositionManager.removeCallParameters = function removeCallParameters(position, options) {
     var calldatas = [];
     var deadline = toHex(options.deadline);
-    var tokenId = toHex(options.tokenId); // construct a partial position with a percentage of liquidity
-
+    var tokenId = toHex(options.tokenId);
+    // construct a partial position with a percentage of liquidity
     var partialPosition = new Position({
       pool: position.pool,
       liquidity: options.liquidityPercentage.multiply(position.liquidity).quotient,
       tickLower: position.tickLower,
       tickUpper: position.tickUpper
     });
-    !JSBI.greaterThan(partialPosition.liquidity, ZERO) ?  invariant(false, 'ZERO_LIQUIDITY')  : void 0; // slippage-adjusted underlying amounts
-
+    !JSBI.greaterThan(partialPosition.liquidity, ZERO) ?  invariant(false, 'ZERO_LIQUIDITY')  : void 0;
+    // slippage-adjusted underlying amounts
     var _partialPosition$burn = partialPosition.burnAmountsWithSlippage(options.slippageTolerance),
-        amount0Min = _partialPosition$burn.amount0,
-        amount1Min = _partialPosition$burn.amount1;
-
+      amount0Min = _partialPosition$burn.amount0,
+      amount1Min = _partialPosition$burn.amount1;
     if (options.permit) {
       calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('permit', [sdkCore.validateAndParseAddress(options.permit.spender), tokenId, toHex(options.permit.deadline), options.permit.v, options.permit.r, options.permit.s]));
-    } // remove liquidity
-
-
+    }
+    // remove liquidity
     calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('decreaseLiquidity', [{
       tokenId: tokenId,
       liquidity: toHex(partialPosition.liquidity),
@@ -3690,19 +2802,16 @@ var NonfungiblePositionManager = /*#__PURE__*/function () {
       amount1Min: toHex(amount1Min),
       deadline: deadline
     }]));
-
     var _options$collectOptio = options.collectOptions,
-        expectedCurrencyOwed0 = _options$collectOptio.expectedCurrencyOwed0,
-        expectedCurrencyOwed1 = _options$collectOptio.expectedCurrencyOwed1,
-        rest = _objectWithoutPropertiesLoose(_options$collectOptio, ["expectedCurrencyOwed0", "expectedCurrencyOwed1"]);
-
+      expectedCurrencyOwed0 = _options$collectOptio.expectedCurrencyOwed0,
+      expectedCurrencyOwed1 = _options$collectOptio.expectedCurrencyOwed1,
+      rest = _objectWithoutPropertiesLoose(_options$collectOptio, _excluded);
     calldatas.push.apply(calldatas, NonfungiblePositionManager.encodeCollect(_extends({
       tokenId: toHex(options.tokenId),
       // add the underlying value to the expected currency already owed
       expectedCurrencyOwed0: expectedCurrencyOwed0.add(sdkCore.CurrencyAmount.fromRawAmount(expectedCurrencyOwed0.currency, amount0Min)),
       expectedCurrencyOwed1: expectedCurrencyOwed1.add(sdkCore.CurrencyAmount.fromRawAmount(expectedCurrencyOwed1.currency, amount1Min))
     }, rest)));
-
     if (options.liquidityPercentage.equalTo(ONE)) {
       if (options.burnToken) {
         calldatas.push(NonfungiblePositionManager.INTERFACE.encodeFunctionData('burn', [tokenId]));
@@ -3710,30 +2819,25 @@ var NonfungiblePositionManager = /*#__PURE__*/function () {
     } else {
       !(options.burnToken !== true) ?  invariant(false, 'CANNOT_BURN')  : void 0;
     }
-
     return {
       calldata: Multicall.encodeMulticall(calldatas),
       value: toHex(0)
     };
   };
-
   NonfungiblePositionManager.safeTransferFromParameters = function safeTransferFromParameters(options) {
     var recipient = sdkCore.validateAndParseAddress(options.recipient);
     var sender = sdkCore.validateAndParseAddress(options.sender);
     var calldata;
-
     if (options.data) {
       calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256,bytes)', [sender, recipient, toHex(options.tokenId), options.data]);
     } else {
       calldata = NonfungiblePositionManager.INTERFACE.encodeFunctionData('safeTransferFrom(address,address,uint256)', [sender, recipient, toHex(options.tokenId)]);
     }
-
     return {
       calldata: calldata,
       value: toHex(0)
     };
   };
-
   return NonfungiblePositionManager;
 }();
 NonfungiblePositionManager.INTERFACE = /*#__PURE__*/new abi.Interface(INonfungiblePositionManager.abi);
@@ -3742,10 +2846,8 @@ NonfungiblePositionManager.INTERFACE = /*#__PURE__*/new abi.Interface(INonfungib
  * Represents the Uniswap V3 QuoterV1 contract with a method for returning the formatted
  * calldata needed to call the quoter contract.
  */
-
 var SwapQuoter = /*#__PURE__*/function () {
   function SwapQuoter() {}
-
   /**
    * Produces the on-chain method name of the appropriate function within QuoterV2,
    * and the relevant hex encoded parameters.
@@ -3761,48 +2863,38 @@ var SwapQuoter = /*#__PURE__*/function () {
     if (options === void 0) {
       options = {};
     }
-
     var singleHop = route.pools.length === 1;
     var quoteAmount = toHex(amount.quotient);
     var calldata;
     var swapInterface = options.useQuoterV2 ? this.V2INTERFACE : this.V1INTERFACE;
-
     if (singleHop) {
       var _options$sqrtPriceLim, _options;
-
       var baseQuoteParams = {
         tokenIn: route.tokenPath[0].address,
         tokenOut: route.tokenPath[1].address,
         fee: route.pools[0].fee,
         sqrtPriceLimitX96: toHex((_options$sqrtPriceLim = (_options = options) == null ? void 0 : _options.sqrtPriceLimitX96) != null ? _options$sqrtPriceLim : 0)
       };
-
-      var v2QuoteParams = _extends({}, baseQuoteParams, tradeType == sdkCore.TradeType.EXACT_INPUT ? {
+      var v2QuoteParams = _extends({}, baseQuoteParams, tradeType === sdkCore.TradeType.EXACT_INPUT ? {
         amountIn: quoteAmount
       } : {
         amount: quoteAmount
       });
-
       var v1QuoteParams = [baseQuoteParams.tokenIn, baseQuoteParams.tokenOut, baseQuoteParams.fee, quoteAmount, baseQuoteParams.sqrtPriceLimitX96];
       var tradeTypeFunctionName = tradeType === sdkCore.TradeType.EXACT_INPUT ? 'quoteExactInputSingle' : 'quoteExactOutputSingle';
       calldata = swapInterface.encodeFunctionData(tradeTypeFunctionName, options.useQuoterV2 ? [v2QuoteParams] : v1QuoteParams);
     } else {
       var _options2;
-
       !(((_options2 = options) == null ? void 0 : _options2.sqrtPriceLimitX96) === undefined) ?  invariant(false, 'MULTIHOP_PRICE_LIMIT')  : void 0;
       var path = encodeRouteToPath(route, tradeType === sdkCore.TradeType.EXACT_OUTPUT);
-
       var _tradeTypeFunctionName = tradeType === sdkCore.TradeType.EXACT_INPUT ? 'quoteExactInput' : 'quoteExactOutput';
-
       calldata = swapInterface.encodeFunctionData(_tradeTypeFunctionName, [path, quoteAmount]);
     }
-
     return {
       calldata: calldata,
       value: toHex(0)
     };
   };
-
   return SwapQuoter;
 }();
 SwapQuoter.V1INTERFACE = /*#__PURE__*/new abi.Interface(IQuoter.abi);
@@ -3816,11 +2908,8 @@ var Staker = /*#__PURE__*/function () {
    * @param options Options for producing the calldata to claim. Can't claim unless you unstake.
    * @returns The calldatas for 'unstakeToken' and 'claimReward'.
    */
-
-
   Staker.encodeClaim = function encodeClaim(incentiveKey, options) {
     var _options$amount;
-
     var calldatas = [];
     calldatas.push(Staker.INTERFACE.encodeFunctionData('unstakeToken', [this._encodeIncentiveKey(incentiveKey), toHex(options.tokenId)]));
     var recipient = sdkCore.validateAndParseAddress(options.recipient);
@@ -3836,22 +2925,18 @@ var Staker = /*#__PURE__*/function () {
    * @param options ClaimOptions to specify tokenId, recipient, and amount wanting to collect.
    * Note that you can only specify one amount and one recipient across the various programs if you are collecting from multiple programs at once.
    * @returns
-   */
-  ;
-
+   */;
   Staker.collectRewards = function collectRewards(incentiveKeys, options) {
     incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
     var calldatas = [];
-
     for (var i = 0; i < incentiveKeys.length; i++) {
       // the unique program tokenId is staked in
-      var incentiveKey = incentiveKeys[i]; // unstakes and claims for the unique program
-
-      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, options)); // re-stakes the position for the unique program
-
+      var incentiveKey = incentiveKeys[i];
+      // unstakes and claims for the unique program
+      calldatas = calldatas.concat(this.encodeClaim(incentiveKey, options));
+      // re-stakes the position for the unique program
       calldatas.push(Staker.INTERFACE.encodeFunctionData('stakeToken', [this._encodeIncentiveKey(incentiveKey), toHex(options.tokenId)]));
     }
-
     return {
       calldata: Multicall.encodeMulticall(calldatas),
       value: toHex(0)
@@ -3862,9 +2947,7 @@ var Staker = /*#__PURE__*/function () {
    * @param incentiveKeys A list of incentiveKeys to unstake from. Should include all incentiveKeys (unique staking programs) that `options.tokenId` is staked in.
    * @param withdrawOptions Options for producing claim calldata and withdraw calldata. Can't withdraw without unstaking all programs for `tokenId`.
    * @returns Calldata for unstaking, claiming, and withdrawing.
-   */
-  ;
-
+   */;
   Staker.withdrawToken = function withdrawToken(incentiveKeys, withdrawOptions) {
     var calldatas = [];
     incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
@@ -3873,12 +2956,10 @@ var Staker = /*#__PURE__*/function () {
       recipient: withdrawOptions.recipient,
       amount: withdrawOptions.amount
     };
-
     for (var i = 0; i < incentiveKeys.length; i++) {
       var incentiveKey = incentiveKeys[i];
       calldatas = calldatas.concat(this.encodeClaim(incentiveKey, claimOptions));
     }
-
     var owner = sdkCore.validateAndParseAddress(withdrawOptions.owner);
     calldatas.push(Staker.INTERFACE.encodeFunctionData('withdrawToken', [toHex(withdrawOptions.tokenId), owner, withdrawOptions.data ? withdrawOptions.data : toHex(0)]));
     return {
@@ -3890,40 +2971,32 @@ var Staker = /*#__PURE__*/function () {
    *
    * @param incentiveKeys A single IncentiveKey or array of IncentiveKeys to be encoded and used in the data parameter in `safeTransferFrom`
    * @returns An IncentiveKey as a string
-   */
-  ;
-
+   */;
   Staker.encodeDeposit = function encodeDeposit(incentiveKeys) {
     incentiveKeys = Array.isArray(incentiveKeys) ? incentiveKeys : [incentiveKeys];
     var data;
-
     if (incentiveKeys.length > 1) {
       var keys = [];
-
       for (var i = 0; i < incentiveKeys.length; i++) {
         var incentiveKey = incentiveKeys[i];
         keys.push(this._encodeIncentiveKey(incentiveKey));
       }
-
       data = abi.defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI + "[]"], [keys]);
     } else {
       data = abi.defaultAbiCoder.encode([Staker.INCENTIVE_KEY_ABI], [this._encodeIncentiveKey(incentiveKeys[0])]);
     }
-
     return data;
   }
   /**
    *
    * @param incentiveKey An `IncentiveKey` which represents a unique staking program.
    * @returns An encoded IncentiveKey to be read by ethers
-   */
-  ;
-
+   */;
   Staker._encodeIncentiveKey = function _encodeIncentiveKey(incentiveKey) {
     var _incentiveKey$pool = incentiveKey.pool,
-        token0 = _incentiveKey$pool.token0,
-        token1 = _incentiveKey$pool.token1,
-        fee = _incentiveKey$pool.fee;
+      token0 = _incentiveKey$pool.token0,
+      token1 = _incentiveKey$pool.token1,
+      fee = _incentiveKey$pool.fee;
     var refundee = sdkCore.validateAndParseAddress(incentiveKey.refundee);
     return {
       rewardToken: incentiveKey.rewardToken.address,
@@ -3933,7 +3006,6 @@ var Staker = /*#__PURE__*/function () {
       refundee: refundee
     };
   };
-
   return Staker;
 }();
 Staker.INTERFACE = /*#__PURE__*/new abi.Interface(IUniswapV3Staker.abi);
@@ -3942,7 +3014,6 @@ Staker.INCENTIVE_KEY_ABI = 'tuple(address rewardToken, address pool, uint256 sta
 /**
  * Represents the Uniswap V3 SwapRouter, and has static methods for helping execute trades.
  */
-
 var SwapRouter = /*#__PURE__*/function () {
   /**
    * Cannot be constructed.
@@ -3953,17 +3024,14 @@ var SwapRouter = /*#__PURE__*/function () {
    * @param trade to produce call parameters for
    * @param options options for the call parameters
    */
-
-
   SwapRouter.swapCallParameters = function swapCallParameters(trades, options) {
     if (!Array.isArray(trades)) {
       trades = [trades];
     }
-
     var sampleTrade = trades[0];
     var tokenIn = sampleTrade.inputAmount.currency.wrapped;
-    var tokenOut = sampleTrade.outputAmount.currency.wrapped; // All trades should have the same starting and ending token.
-
+    var tokenOut = sampleTrade.outputAmount.currency.wrapped;
+    // All trades should have the same starting and ending token.
     !trades.every(function (trade) {
       return trade.inputAmount.currency.wrapped.equals(tokenIn);
     }) ?  invariant(false, 'TOKEN_IN_DIFF')  : void 0;
@@ -3975,42 +3043,37 @@ var SwapRouter = /*#__PURE__*/function () {
     var ZERO_OUT = sdkCore.CurrencyAmount.fromRawAmount(trades[0].outputAmount.currency, 0);
     var totalAmountOut = trades.reduce(function (sum, trade) {
       return sum.add(trade.minimumAmountOut(options.slippageTolerance));
-    }, ZERO_OUT); // flag for whether a refund needs to happen
-
+    }, ZERO_OUT);
+    // flag for whether a refund needs to happen
     var mustRefund = sampleTrade.inputAmount.currency.isNative && sampleTrade.tradeType === sdkCore.TradeType.EXACT_OUTPUT;
-    var inputIsNative = sampleTrade.inputAmount.currency.isNative; // flags for whether funds should be send first to the router
-
+    var inputIsNative = sampleTrade.inputAmount.currency.isNative;
+    // flags for whether funds should be send first to the router
     var outputIsNative = sampleTrade.outputAmount.currency.isNative;
     var routerMustCustody = outputIsNative || !!options.fee;
     var totalValue = inputIsNative ? trades.reduce(function (sum, trade) {
       return sum.add(trade.maximumAmountIn(options.slippageTolerance));
-    }, ZERO_IN) : ZERO_IN; // encode permit if necessary
-
+    }, ZERO_IN) : ZERO_IN;
+    // encode permit if necessary
     if (options.inputTokenPermit) {
       !sampleTrade.inputAmount.currency.isToken ?  invariant(false, 'NON_TOKEN_PERMIT')  : void 0;
       calldatas.push(SelfPermit.encodePermit(sampleTrade.inputAmount.currency, options.inputTokenPermit));
     }
-
     var recipient = sdkCore.validateAndParseAddress(options.recipient);
     var deadline = toHex(options.deadline);
-
     for (var _iterator = _createForOfIteratorHelperLoose(trades), _step; !(_step = _iterator()).done;) {
       var trade = _step.value;
-
       for (var _iterator2 = _createForOfIteratorHelperLoose(trade.swaps), _step2; !(_step2 = _iterator2()).done;) {
         var _step2$value = _step2.value,
-            route = _step2$value.route,
-            inputAmount = _step2$value.inputAmount,
-            outputAmount = _step2$value.outputAmount;
+          route = _step2$value.route,
+          inputAmount = _step2$value.inputAmount,
+          outputAmount = _step2$value.outputAmount;
         var amountIn = toHex(trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient);
-        var amountOut = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient); // flag for whether the trade is single hop or not
-
+        var amountOut = toHex(trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient);
+        // flag for whether the trade is single hop or not
         var singleHop = route.pools.length === 1;
-
         if (singleHop) {
           if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {
             var _options$sqrtPriceLim;
-
             var exactInputSingleParams = {
               tokenIn: route.tokenPath[0].address,
               tokenOut: route.tokenPath[1].address,
@@ -4024,7 +3087,6 @@ var SwapRouter = /*#__PURE__*/function () {
             calldatas.push(SwapRouter.INTERFACE.encodeFunctionData('exactInputSingle', [exactInputSingleParams]));
           } else {
             var _options$sqrtPriceLim2;
-
             var exactOutputSingleParams = {
               tokenIn: route.tokenPath[0].address,
               tokenOut: route.tokenPath[1].address,
@@ -4040,7 +3102,6 @@ var SwapRouter = /*#__PURE__*/function () {
         } else {
           !(options.sqrtPriceLimitX96 === undefined) ?  invariant(false, 'MULTIHOP_PRICE_LIMIT')  : void 0;
           var path = encodeRouteToPath(route, trade.tradeType === sdkCore.TradeType.EXACT_OUTPUT);
-
           if (trade.tradeType === sdkCore.TradeType.EXACT_INPUT) {
             var exactInputParams = {
               path: path,
@@ -4062,9 +3123,8 @@ var SwapRouter = /*#__PURE__*/function () {
           }
         }
       }
-    } // unwrap
-
-
+    }
+    // unwrap
     if (routerMustCustody) {
       if (!!options.fee) {
         if (outputIsNative) {
@@ -4075,19 +3135,16 @@ var SwapRouter = /*#__PURE__*/function () {
       } else {
         calldatas.push(Payments.encodeUnwrapWETH9(totalAmountOut.quotient, recipient));
       }
-    } // refund
-
-
+    }
+    // refund
     if (mustRefund) {
       calldatas.push(Payments.encodeRefundETH());
     }
-
     return {
       calldata: Multicall.encodeMulticall(calldatas),
       value: toHex(totalValue.quotient)
     };
   };
-
   return SwapRouter;
 }();
 SwapRouter.INTERFACE = /*#__PURE__*/new abi.Interface(ISwapRouter.abi);
diff --git a/node_modules/@uniswap/v3-sdk/dist/v3-sdk.cjs.production.min.js b/node_modules/@uniswap/v3-sdk/dist/v3-sdk.cjs.production.min.js
index d9f4dda..4db2ee5 100644
--- a/node_modules/@uniswap/v3-sdk/dist/v3-sdk.cjs.production.min.js
+++ b/node_modules/@uniswap/v3-sdk/dist/v3-sdk.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";function t(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@uniswap/sdk-core"),n=t(require("jsbi")),r=t(require("tiny-invariant")),i=require("@ethersproject/abi"),o=require("@ethersproject/address"),u=require("@ethersproject/solidity"),a=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/IMulticall.sol/IMulticall.json")),c=t(require("@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json")),s=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json")),p=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/IPeripheryPaymentsWithFee.sol/IPeripheryPaymentsWithFee.json")),l=t(require("@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json")),d=t(require("@uniswap/swap-router-contracts/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json")),f=t(require("@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json")),h=t(require("@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json"));function m(t,e,n,r,i,o,u){try{var a=t[o](u),c=a.value}catch(t){return void n(t)}a.done?e(c):Promise.resolve(c).then(r,i)}function v(t){return function(){var e=this,n=arguments;return new Promise((function(r,i){var o=t.apply(e,n);function u(t){m(o,r,i,u,a,"next",t)}function a(t){m(o,r,i,u,a,"throw",t)}u(void 0)}))}}function k(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}function y(t,e,n){return e&&k(t.prototype,e),n&&k(t,n),t}function g(){return(g=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}).apply(this,arguments)}function A(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function T(t,e){var n;if("undefined"==typeof Symbol||null==t[Symbol.iterator]){if(Array.isArray(t)||(n=function(t,e){if(t){if("string"==typeof t)return A(t,void 0);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?A(t,void 0):void 0}}(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(n=t[Symbol.iterator]()).next.bind(n)}var x,w,I,q=(function(t){var e=function(t){var e=Object.prototype,n=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",o=r.asyncIterator||"@@asyncIterator",u=r.toStringTag||"@@toStringTag";function a(t,e,n){return Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{a({},"")}catch(t){a=function(t,e,n){return t[e]=n}}function c(t,e,n,r){var i=Object.create((e&&e.prototype instanceof l?e:l).prototype),o=new w(r||[]);return i._invoke=function(t,e,n){var r="suspendedStart";return function(i,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw o;return{value:void 0,done:!0}}for(n.method=i,n.arg=o;;){var u=n.delegate;if(u){var a=A(u,n);if(a){if(a===p)continue;return a}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if("suspendedStart"===r)throw r="completed",n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);r="executing";var c=s(t,e,n);if("normal"===c.type){if(r=n.done?"completed":"suspendedYield",c.arg===p)continue;return{value:c.arg,done:n.done}}"throw"===c.type&&(r="completed",n.method="throw",n.arg=c.arg)}}}(t,n,o),i}function s(t,e,n){try{return{type:"normal",arg:t.call(e,n)}}catch(t){return{type:"throw",arg:t}}}t.wrap=c;var p={};function l(){}function d(){}function f(){}var h={};h[i]=function(){return this};var m=Object.getPrototypeOf,v=m&&m(m(I([])));v&&v!==e&&n.call(v,i)&&(h=v);var k=f.prototype=l.prototype=Object.create(h);function y(t){["next","throw","return"].forEach((function(e){a(t,e,(function(t){return this._invoke(e,t)}))}))}function g(t,e){var r;this._invoke=function(i,o){function u(){return new e((function(r,u){!function r(i,o,u,a){var c=s(t[i],t,o);if("throw"!==c.type){var p=c.arg,l=p.value;return l&&"object"==typeof l&&n.call(l,"__await")?e.resolve(l.__await).then((function(t){r("next",t,u,a)}),(function(t){r("throw",t,u,a)})):e.resolve(l).then((function(t){p.value=t,u(p)}),(function(t){return r("throw",t,u,a)}))}a(c.arg)}(i,o,r,u)}))}return r=r?r.then(u,u):u()}}function A(t,e){var n=t.iterator[e.method];if(void 0===n){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=void 0,A(t,e),"throw"===e.method))return p;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return p}var r=s(n,t.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,p;var i=r.arg;return i?i.done?(e[t.resultName]=i.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,p):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,p)}function T(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function x(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function w(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(T,this),this.reset(!0)}function I(t){if(t){var e=t[i];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,o=function e(){for(;++r<t.length;)if(n.call(t,r))return e.value=t[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return o.next=o}}return{next:q}}function q(){return{value:void 0,done:!0}}return d.prototype=k.constructor=f,f.constructor=d,d.displayName=a(f,u,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===d||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,f):(t.__proto__=f,a(t,u,"GeneratorFunction")),t.prototype=Object.create(k),t},t.awrap=function(t){return{__await:t}},y(g.prototype),g.prototype[o]=function(){return this},t.AsyncIterator=g,t.async=function(e,n,r,i,o){void 0===o&&(o=Promise);var u=new g(c(e,n,r,i),o);return t.isGeneratorFunction(n)?u:u.next().then((function(t){return t.done?t.value:u.next()}))},y(k),a(k,u,"Generator"),k[i]=function(){return this},k.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var n in t)e.push(n);return e.reverse(),function n(){for(;e.length;){var r=e.pop();if(r in t)return n.value=r,n.done=!1,n}return n.done=!0,n}},t.values=I,w.prototype={constructor:w,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(x),!t)for(var e in this)"t"===e.charAt(0)&&n.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function r(n,r){return u.type="throw",u.arg=t,e.next=n,r&&(e.method="next",e.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],u=o.completion;if("root"===o.tryLoc)return r("end");if(o.tryLoc<=this.prev){var a=n.call(o,"catchLoc"),c=n.call(o,"finallyLoc");if(a&&c){if(this.prev<o.catchLoc)return r(o.catchLoc,!0);if(this.prev<o.finallyLoc)return r(o.finallyLoc)}else if(a){if(this.prev<o.catchLoc)return r(o.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return r(o.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&n.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var u=o?o.completion:{};return u.type=t,u.arg=e,o?(this.method="next",this.next=o.finallyLoc,p):this.complete(u)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),p},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.finallyLoc===t)return this.complete(n.completion,n.afterLoc),x(n),p}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.tryLoc===t){var r=n.completion;if("throw"===r.type){var i=r.arg;x(n)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,n){return this.delegate={iterator:I(t),resultName:e,nextLoc:n},"next"===this.method&&(this.arg=void 0),p}},t}(t.exports);try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}}(I={exports:{}}),I.exports),b="0x0000000000000000000000000000000000000000",R="0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54";(w=exports.FeeAmount||(exports.FeeAmount={}))[w.LOWEST=100]="LOWEST",w[w.LOW=500]="LOW",w[w.MEDIUM=3e3]="MEDIUM",w[w.HIGH=1e4]="HIGH";var E=((x={})[exports.FeeAmount.LOWEST]=1,x[exports.FeeAmount.LOW]=10,x[exports.FeeAmount.MEDIUM]=60,x[exports.FeeAmount.HIGH]=200,x),P=n.BigInt(-1),C=n.BigInt(0),S=n.BigInt(1),O=n.exponentiate(n.BigInt(2),n.BigInt(96)),N=n.exponentiate(O,n.BigInt(2));function _(t){var e=t.factoryAddress,n=t.tokenA,r=t.tokenB,a=t.fee,c=t.initCodeHashManualOverride,s=n.sortsBefore(r)?[n,r]:[r,n];return o.getCreate2Address(e,u.keccak256(["bytes"],[i.defaultAbiCoder.encode(["address","address","uint24"],[s[0].address,s[1].address,a])]),null!=c?c:R)}var F=function(){function t(){}return t.addDelta=function(t,e){return n.lessThan(e,C)?n.subtract(t,n.multiply(e,P)):n.add(t,e)},t}(),X=function(){function t(){}return t.mulDivRoundingUp=function(t,e,r){var i=n.multiply(t,e),o=n.divide(i,r);return n.notEqual(n.remainder(i,r),C)&&(o=n.add(o,S)),o},t}(),L=n.subtract(n.exponentiate(n.BigInt(2),n.BigInt(160)),S);function U(t,r){var i=n.multiply(t,r);return n.bitwiseAnd(i,e.MaxUint256)}var B=function(){function t(){}return t.getAmount0Delta=function(t,e,r,i){if(n.greaterThan(t,e)){var o=[e,t];t=o[0],e=o[1]}var u=n.leftShift(r,n.BigInt(96)),a=n.subtract(e,t);return i?X.mulDivRoundingUp(X.mulDivRoundingUp(u,a,e),S,t):n.divide(n.divide(n.multiply(u,a),e),t)},t.getAmount1Delta=function(t,e,r,i){if(n.greaterThan(t,e)){var o=[e,t];t=o[0],e=o[1]}return i?X.mulDivRoundingUp(r,n.subtract(e,t),O):n.divide(n.multiply(r,n.subtract(e,t)),O)},t.getNextSqrtPriceFromInput=function(t,e,i,o){return n.greaterThan(t,C)||r(!1),n.greaterThan(e,C)||r(!1),o?this.getNextSqrtPriceFromAmount0RoundingUp(t,e,i,!0):this.getNextSqrtPriceFromAmount1RoundingDown(t,e,i,!0)},t.getNextSqrtPriceFromOutput=function(t,e,i,o){return n.greaterThan(t,C)||r(!1),n.greaterThan(e,C)||r(!1),o?this.getNextSqrtPriceFromAmount1RoundingDown(t,e,i,!1):this.getNextSqrtPriceFromAmount0RoundingUp(t,e,i,!1)},t.getNextSqrtPriceFromAmount0RoundingUp=function(t,i,o,u){if(n.equal(o,C))return t;var a=n.leftShift(i,n.BigInt(96));if(u){var c=U(o,t);if(n.equal(n.divide(c,o),t)){var s=(l=n.add(a,c),n.bitwiseAnd(l,e.MaxUint256));if(n.greaterThanOrEqual(s,a))return X.mulDivRoundingUp(a,t,s)}return X.mulDivRoundingUp(a,S,n.add(n.divide(a,t),o))}var p=U(o,t);n.equal(n.divide(p,o),t)||r(!1),n.greaterThan(a,p)||r(!1);var l,d=n.subtract(a,p);return X.mulDivRoundingUp(a,t,d)},t.getNextSqrtPriceFromAmount1RoundingDown=function(t,e,i,o){if(o){var u=n.lessThanOrEqual(i,L)?n.divide(n.leftShift(i,n.BigInt(96)),e):n.divide(n.multiply(i,O),e);return n.add(t,u)}var a=X.mulDivRoundingUp(i,O,e);return n.greaterThan(t,a)||r(!1),n.subtract(t,a)},t}(),M=n.exponentiate(n.BigInt(10),n.BigInt(6)),D=function(){function t(){}return t.computeSwapStep=function(t,e,r,i,o){var u={},a=n.greaterThanOrEqual(t,e),c=n.greaterThanOrEqual(i,C);if(c){var s=n.divide(n.multiply(i,n.subtract(M,n.BigInt(o))),M);u.amountIn=a?B.getAmount0Delta(e,t,r,!0):B.getAmount1Delta(t,e,r,!0),u.sqrtRatioNextX96=n.greaterThanOrEqual(s,u.amountIn)?e:B.getNextSqrtPriceFromInput(t,r,s,a)}else u.amountOut=a?B.getAmount1Delta(e,t,r,!1):B.getAmount0Delta(t,e,r,!1),u.sqrtRatioNextX96=n.greaterThanOrEqual(n.multiply(i,P),u.amountOut)?e:B.getNextSqrtPriceFromOutput(t,r,n.multiply(i,P),a);var p=n.equal(e,u.sqrtRatioNextX96);return a?(u.amountIn=p&&c?u.amountIn:B.getAmount0Delta(u.sqrtRatioNextX96,t,r,!0),u.amountOut=p&&!c?u.amountOut:B.getAmount1Delta(u.sqrtRatioNextX96,t,r,!1)):(u.amountIn=p&&c?u.amountIn:B.getAmount1Delta(t,u.sqrtRatioNextX96,r,!0),u.amountOut=p&&!c?u.amountOut:B.getAmount0Delta(t,u.sqrtRatioNextX96,r,!1)),!c&&n.greaterThan(u.amountOut,n.multiply(i,P))&&(u.amountOut=n.multiply(i,P)),u.feeAmount=c&&n.notEqual(u.sqrtRatioNextX96,e)?n.subtract(i,u.amountIn):X.mulDivRoundingUp(u.amountIn,n.BigInt(o),n.subtract(M,n.BigInt(o))),[u.sqrtRatioNextX96,u.amountIn,u.amountOut,u.feeAmount]},t}(),j=n.BigInt(2),W=[128,64,32,16,8,4,2,1].map((function(t){return[t,n.exponentiate(j,n.BigInt(t))]}));function G(t){n.greaterThan(t,C)||r(!1),n.lessThanOrEqual(t,e.MaxUint256)||r(!1);for(var i,o=0,u=T(W);!(i=u()).done;){var a=i.value,c=a[0];n.greaterThanOrEqual(t,a[1])&&(t=n.signedRightShift(t,n.BigInt(c)),o+=c)}return o}function K(t,e){return n.signedRightShift(n.multiply(t,n.BigInt(e)),n.BigInt(128))}var H=n.exponentiate(n.BigInt(2),n.BigInt(32)),Q=function(){function t(){}return t.getSqrtRatioAtTick=function(i){i>=t.MIN_TICK&&i<=t.MAX_TICK&&Number.isInteger(i)||r(!1);var o=i<0?-1*i:i,u=n.BigInt(0!=(1&o)?"0xfffcb933bd6fad37aa2d162d1a594001":"0x100000000000000000000000000000000");return 0!=(2&o)&&(u=K(u,"0xfff97272373d413259a46990580e213a")),0!=(4&o)&&(u=K(u,"0xfff2e50f5f656932ef12357cf3c7fdcc")),0!=(8&o)&&(u=K(u,"0xffe5caca7e10e4e61c3624eaa0941cd0")),0!=(16&o)&&(u=K(u,"0xffcb9843d60f6159c9db58835c926644")),0!=(32&o)&&(u=K(u,"0xff973b41fa98c081472e6896dfb254c0")),0!=(64&o)&&(u=K(u,"0xff2ea16466c96a3843ec78b326b52861")),0!=(128&o)&&(u=K(u,"0xfe5dee046a99a2a811c461f1969c3053")),0!=(256&o)&&(u=K(u,"0xfcbe86c7900a88aedcffc83b479aa3a4")),0!=(512&o)&&(u=K(u,"0xf987a7253ac413176f2b074cf7815e54")),0!=(1024&o)&&(u=K(u,"0xf3392b0822b70005940c7a398e4b70f3")),0!=(2048&o)&&(u=K(u,"0xe7159475a2c29b7443b29c7fa6e889d9")),0!=(4096&o)&&(u=K(u,"0xd097f3bdfd2022b8845ad8f792aa5825")),0!=(8192&o)&&(u=K(u,"0xa9f746462d870fdf8a65dc1f90e061e5")),0!=(16384&o)&&(u=K(u,"0x70d869a156d2a1b890bb3df62baf32f7")),0!=(32768&o)&&(u=K(u,"0x31be135f97d08fd981231505542fcfa6")),0!=(65536&o)&&(u=K(u,"0x9aa508b5b7a84e1c677de54f3e99bc9")),0!=(131072&o)&&(u=K(u,"0x5d6af8dedb81196699c329225ee604")),0!=(262144&o)&&(u=K(u,"0x2216e584f5fa1ea926041bedfe98")),0!=(524288&o)&&(u=K(u,"0x48a170391f7dc42444e8fa2")),i>0&&(u=n.divide(e.MaxUint256,u)),n.greaterThan(n.remainder(u,H),C)?n.add(n.divide(u,H),S):n.divide(u,H)},t.getTickAtSqrtRatio=function(e){n.greaterThanOrEqual(e,t.MIN_SQRT_RATIO)&&n.lessThan(e,t.MAX_SQRT_RATIO)||r(!1);var i,o=n.leftShift(e,n.BigInt(32)),u=G(o);i=n.greaterThanOrEqual(n.BigInt(u),n.BigInt(128))?n.signedRightShift(o,n.BigInt(u-127)):n.leftShift(o,n.BigInt(127-u));for(var a=n.leftShift(n.subtract(n.BigInt(u),n.BigInt(128)),n.BigInt(64)),c=0;c<14;c++){i=n.signedRightShift(n.multiply(i,i),n.BigInt(127));var s=n.signedRightShift(i,n.BigInt(128));a=n.bitwiseOr(a,n.leftShift(s,n.BigInt(63-c))),i=n.signedRightShift(i,s)}var p=n.multiply(a,n.BigInt("255738958999603826347141")),l=n.toNumber(n.signedRightShift(n.subtract(p,n.BigInt("3402992956809132418596140100660247210")),n.BigInt(128))),d=n.toNumber(n.signedRightShift(n.add(p,n.BigInt("291339464771989622907027621153398088495")),n.BigInt(128)));return l===d?l:n.lessThanOrEqual(t.getSqrtRatioAtTick(d),e)?d:l},t}();Q.MIN_TICK=-887272,Q.MAX_TICK=-Q.MIN_TICK,Q.MIN_SQRT_RATIO=n.BigInt("4295128739"),Q.MAX_SQRT_RATIO=n.BigInt("1461446703485210103287273052203988822378723970342");var V=function(){function t(){}var e=t.prototype;return e.getTick=function(){var e=v(q.mark((function e(n){return q.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:throw new Error(t.ERROR_MESSAGE);case 1:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),e.nextInitializedTickWithinOneWord=function(){var e=v(q.mark((function e(n,r,i){return q.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:throw new Error(t.ERROR_MESSAGE);case 1:case"end":return e.stop()}}),e)})));return function(t,n,r){return e.apply(this,arguments)}}(),t}();function z(t,e){for(var n=0;n<t.length-1;n++)if(e(t[n],t[n+1])>0)return!1;return!0}function Y(t,e){return t.index-e.index}V.ERROR_MESSAGE="No tick data provider was given";var Z=function(){function t(){}return t.validateList=function(t,e){e>0||r(!1),t.every((function(t){return t.index%e==0}))||r(!1),n.equal(t.reduce((function(t,e){return n.add(t,e.liquidityNet)}),C),C)||r(!1),z(t,Y)||r(!1)},t.isBelowSmallest=function(t,e){return t.length>0||r(!1),e<t[0].index},t.isAtOrAboveLargest=function(t,e){return t.length>0||r(!1),e>=t[t.length-1].index},t.getTick=function(t,e){var n=t[this.binarySearch(t,e)];return n.index!==e&&r(!1),n},t.binarySearch=function(t,e){this.isBelowSmallest(t,e)&&r(!1);for(var n,i=0,o=t.length-1;;){if(t[n=Math.floor((i+o)/2)].index<=e&&(n===t.length-1||t[n+1].index>e))return n;t[n].index<e?i=n+1:o=n-1}},t.nextInitializedTick=function(e,n,i){return i?(t.isBelowSmallest(e,n)&&r(!1),t.isAtOrAboveLargest(e,n)?e[e.length-1]:e[this.binarySearch(e,n)]):(this.isAtOrAboveLargest(e,n)&&r(!1),this.isBelowSmallest(e,n)?e[0]:e[this.binarySearch(e,n)+1])},t.nextInitializedTickWithinOneWord=function(e,n,r,i){var o=Math.floor(n/i);if(r){var u=(o>>8<<8)*i;if(t.isBelowSmallest(e,n))return[u,!1];var a=t.nextInitializedTick(e,n,r).index,c=Math.max(u,a);return[c,c===a]}var s=((1+(o+1>>8)<<8)-1)*i;if(this.isAtOrAboveLargest(e,n))return[s,!1];var p=this.nextInitializedTick(e,n,r).index,l=Math.min(s,p);return[l,l===p]},t}();function $(t){var e=n.BigInt(t).toString(16);return e.length%2!=0&&(e="0"+e),"0x"+e}function J(t,e){var n=t.pools.reduce((function(t,e,n){var r=t.inputToken,i=t.path,o=t.types,u=e.token0.equals(r)?e.token1:e.token0;return 0===n?{inputToken:u,types:["address","uint24","address"],path:[r.address,e.fee,u.address]}:{inputToken:u,types:[].concat(o,["uint24","address"]),path:[].concat(i,[e.fee,u.address])}}),{inputToken:t.input.wrapped,path:[],types:[]}),r=n.path,i=n.types;return e?u.pack(i.reverse(),r.reverse()):u.pack(i,r)}function tt(t,r){var i=n.leftShift(n.BigInt(t),n.BigInt(192)),o=n.BigInt(r),u=n.divide(i,o);return e.sqrt(u)}function et(t,e,r){if(n.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}var o=n.divide(n.multiply(t,e),O);return n.divide(n.multiply(n.BigInt(r),o),n.subtract(e,t))}function nt(t,e,r){if(n.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}var o=n.multiply(n.multiply(n.BigInt(r),t),e),u=n.multiply(O,n.subtract(e,t));return n.divide(o,u)}function rt(t,e,r){if(n.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}return n.divide(n.multiply(n.BigInt(r),O),n.subtract(e,t))}function it(t,e,r,i,o,u){if(n.greaterThan(e,r)){var a=[r,e];e=a[0],r=a[1]}var c=u?nt:et;if(n.lessThanOrEqual(t,e))return c(e,r,i);if(n.lessThan(t,r)){var s=c(t,r,i),p=rt(e,t,o);return n.lessThan(s,p)?s:p}return rt(e,r,o)}var ot=n.exponentiate(n.BigInt(2),n.BigInt(128)),ut=function(){function t(){}return t.getTokensOwed=function(t,e,r,i,o){return[n.divide(n.multiply(st(i,t),r),ot),n.divide(n.multiply(st(o,e),r),ot)]},t}();function at(t,r,i){var o=Q.getSqrtRatioAtTick(i),u=n.multiply(o,o);return t.sortsBefore(r)?new e.Price(t,r,N,u):new e.Price(t,r,u,N)}var ct=n.exponentiate(n.BigInt(2),n.BigInt(256));function st(t,e){var r=n.subtract(t,e);return n.lessThan(r,C)?n.add(ct,r):r}var pt=function(){function t(){}return t.getFeeGrowthInside=function(t,e,n,r,i,o,u){var a,c,s,p;return i>=n?(a=t.feeGrowthOutside0X128,c=t.feeGrowthOutside1X128):(a=st(o,t.feeGrowthOutside0X128),c=st(u,t.feeGrowthOutside1X128)),i<r?(s=e.feeGrowthOutside0X128,p=e.feeGrowthOutside1X128):(s=st(o,e.feeGrowthOutside0X128),p=st(u,e.feeGrowthOutside1X128)),[st(st(o,a),s),st(st(u,c),p)]},t}(),lt=function(t){var e=t.index,i=t.liquidityGross,o=t.liquidityNet;e>=Q.MIN_TICK&&e<=Q.MAX_TICK||r(!1),this.index=e,this.liquidityGross=n.BigInt(i),this.liquidityNet=n.BigInt(o)},dt=function(){function t(t,e){var n=t.map((function(t){return t instanceof lt?t:new lt(t)}));Z.validateList(n,e),this.ticks=n}var e=t.prototype;return e.getTick=function(){var t=v(q.mark((function t(e){return q.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",Z.getTick(this.ticks,e));case 1:case"end":return t.stop()}}),t,this)})));return function(e){return t.apply(this,arguments)}}(),e.nextInitializedTickWithinOneWord=function(){var t=v(q.mark((function t(e,n,r){return q.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",Z.nextInitializedTickWithinOneWord(this.ticks,e,n,r));case 1:case"end":return t.stop()}}),t,this)})));return function(e,n,r){return t.apply(this,arguments)}}(),t}(),ft=new V,ht=function(){function t(t,e,i,o,u,a,c){void 0===c&&(c=ft),Number.isInteger(i)&&i<1e6||r(!1);var s=Q.getSqrtRatioAtTick(a),p=Q.getSqrtRatioAtTick(a+1);n.greaterThanOrEqual(n.BigInt(o),s)&&n.lessThanOrEqual(n.BigInt(o),p)||r(!1);var l=t.sortsBefore(e)?[t,e]:[e,t];this.token0=l[0],this.token1=l[1],this.fee=i,this.sqrtRatioX96=n.BigInt(o),this.liquidity=n.BigInt(u),this.tickCurrent=a,this.tickDataProvider=Array.isArray(c)?new dt(c,E[i]):c}t.getAddress=function(t,e,n,r,i){return _({factoryAddress:null!=i?i:"0x1F98431c8aD98523631AE4a59f267346ea31F984",fee:n,tokenA:t,tokenB:e,initCodeHashManualOverride:r})};var i=t.prototype;return i.involvesToken=function(t){return t.equals(this.token0)||t.equals(this.token1)},i.priceOf=function(t){return this.involvesToken(t)||r(!1),t.equals(this.token0)?this.token0Price:this.token1Price},i.getOutputAmount=function(){var i=v(q.mark((function i(o,u){var a,c,s,p,l;return q.wrap((function(i){for(;;)switch(i.prev=i.next){case 0:return this.involvesToken(o.currency)||r(!1),a=o.currency.equals(this.token0),i.next=4,this.swap(a,o.quotient,u);case 4:return s=(c=i.sent).sqrtRatioX96,p=c.liquidity,l=c.tickCurrent,i.abrupt("return",[e.CurrencyAmount.fromRawAmount(a?this.token1:this.token0,n.multiply(c.amountCalculated,P)),new t(this.token0,this.token1,this.fee,s,p,l,this.tickDataProvider)]);case 11:case"end":return i.stop()}}),i,this)})));return function(t,e){return i.apply(this,arguments)}}(),i.getInputAmount=function(){var i=v(q.mark((function i(o,u){var a,c,s,p,l;return q.wrap((function(i){for(;;)switch(i.prev=i.next){case 0:return o.currency.isToken&&this.involvesToken(o.currency)||r(!1),a=o.currency.equals(this.token1),i.next=4,this.swap(a,n.multiply(o.quotient,P),u);case 4:return s=(c=i.sent).sqrtRatioX96,p=c.liquidity,l=c.tickCurrent,i.abrupt("return",[e.CurrencyAmount.fromRawAmount(a?this.token0:this.token1,c.amountCalculated),new t(this.token0,this.token1,this.fee,s,p,l,this.tickDataProvider)]);case 11:case"end":return i.stop()}}),i,this)})));return function(t,e){return i.apply(this,arguments)}}(),i.swap=function(){var t=v(q.mark((function t(e,i,o){var u,a,c,s,p,l;return q.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:o||(o=e?n.add(Q.MIN_SQRT_RATIO,S):n.subtract(Q.MAX_SQRT_RATIO,S)),e?(n.greaterThan(o,Q.MIN_SQRT_RATIO)||r(!1),n.lessThan(o,this.sqrtRatioX96)||r(!1)):(n.lessThan(o,Q.MAX_SQRT_RATIO)||r(!1),n.greaterThan(o,this.sqrtRatioX96)||r(!1)),u=n.greaterThanOrEqual(i,C),a={amountSpecifiedRemaining:i,amountCalculated:C,sqrtPriceX96:this.sqrtRatioX96,tick:this.tickCurrent,liquidity:this.liquidity};case 4:if(!n.notEqual(a.amountSpecifiedRemaining,C)||a.sqrtPriceX96==o){t.next=35;break}return(c={}).sqrtPriceStartX96=a.sqrtPriceX96,t.next=9,this.tickDataProvider.nextInitializedTickWithinOneWord(a.tick,e,this.tickSpacing);case 9:if(c.tickNext=(s=t.sent)[0],c.initialized=s[1],c.tickNext<Q.MIN_TICK?c.tickNext=Q.MIN_TICK:c.tickNext>Q.MAX_TICK&&(c.tickNext=Q.MAX_TICK),c.sqrtPriceNextX96=Q.getSqrtRatioAtTick(c.tickNext),p=D.computeSwapStep(a.sqrtPriceX96,(e?n.lessThan(c.sqrtPriceNextX96,o):n.greaterThan(c.sqrtPriceNextX96,o))?o:c.sqrtPriceNextX96,a.liquidity,a.amountSpecifiedRemaining,this.fee),a.sqrtPriceX96=p[0],c.amountIn=p[1],c.amountOut=p[2],c.feeAmount=p[3],u?(a.amountSpecifiedRemaining=n.subtract(a.amountSpecifiedRemaining,n.add(c.amountIn,c.feeAmount)),a.amountCalculated=n.subtract(a.amountCalculated,c.amountOut)):(a.amountSpecifiedRemaining=n.add(a.amountSpecifiedRemaining,c.amountOut),a.amountCalculated=n.add(a.amountCalculated,n.add(c.amountIn,c.feeAmount))),!n.equal(a.sqrtPriceX96,c.sqrtPriceNextX96)){t.next=32;break}if(!c.initialized){t.next=29;break}return t.t0=n,t.next=25,this.tickDataProvider.getTick(c.tickNext);case 25:t.t1=t.sent.liquidityNet,l=t.t0.BigInt.call(t.t0,t.t1),e&&(l=n.multiply(l,P)),a.liquidity=F.addDelta(a.liquidity,l);case 29:a.tick=e?c.tickNext-1:c.tickNext,t.next=33;break;case 32:a.sqrtPriceX96!=c.sqrtPriceStartX96&&(a.tick=Q.getTickAtSqrtRatio(a.sqrtPriceX96));case 33:t.next=4;break;case 35:return t.abrupt("return",{amountCalculated:a.amountCalculated,sqrtRatioX96:a.sqrtPriceX96,liquidity:a.liquidity,tickCurrent:a.tick});case 36:case"end":return t.stop()}}),t,this)})));return function(e,n,r){return t.apply(this,arguments)}}(),y(t,[{key:"token0Price",get:function(){var t;return null!=(t=this._token0Price)?t:this._token0Price=new e.Price(this.token0,this.token1,N,n.multiply(this.sqrtRatioX96,this.sqrtRatioX96))}},{key:"token1Price",get:function(){var t;return null!=(t=this._token1Price)?t:this._token1Price=new e.Price(this.token1,this.token0,n.multiply(this.sqrtRatioX96,this.sqrtRatioX96),N)}},{key:"chainId",get:function(){return this.token0.chainId}},{key:"tickSpacing",get:function(){return E[this.fee]}}]),t}(),mt=function(){function t(t){var e=t.pool,i=t.liquidity,o=t.tickLower,u=t.tickUpper;this._token0Amount=null,this._token1Amount=null,this._mintAmounts=null,o<u||r(!1),o>=Q.MIN_TICK&&o%e.tickSpacing==0||r(!1),u<=Q.MAX_TICK&&u%e.tickSpacing==0||r(!1),this.pool=e,this.tickLower=o,this.tickUpper=u,this.liquidity=n.BigInt(i)}var i=t.prototype;return i.ratiosAfterSlippage=function(t){var r=this.pool.token0Price.asFraction.multiply(new e.Percent(1).subtract(t)),i=this.pool.token0Price.asFraction.multiply(t.add(1)),o=tt(r.numerator,r.denominator);n.lessThanOrEqual(o,Q.MIN_SQRT_RATIO)&&(o=n.add(Q.MIN_SQRT_RATIO,n.BigInt(1)));var u=tt(i.numerator,i.denominator);return n.greaterThanOrEqual(u,Q.MAX_SQRT_RATIO)&&(u=n.subtract(Q.MAX_SQRT_RATIO,n.BigInt(1))),{sqrtRatioX96Lower:o,sqrtRatioX96Upper:u}},i.mintAmountsWithSlippage=function(e){var n=this.ratiosAfterSlippage(e),r=n.sqrtRatioX96Upper,i=n.sqrtRatioX96Lower,o=new ht(this.pool.token0,this.pool.token1,this.pool.fee,i,0,Q.getTickAtSqrtRatio(i)),u=new ht(this.pool.token0,this.pool.token1,this.pool.fee,r,0,Q.getTickAtSqrtRatio(r)),a=t.fromAmounts(g({pool:this.pool,tickLower:this.tickLower,tickUpper:this.tickUpper},this.mintAmounts,{useFullPrecision:!1}));return{amount0:new t({pool:u,liquidity:a.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).mintAmounts.amount0,amount1:new t({pool:o,liquidity:a.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).mintAmounts.amount1}},i.burnAmountsWithSlippage=function(e){var n=this.ratiosAfterSlippage(e),r=n.sqrtRatioX96Upper,i=n.sqrtRatioX96Lower,o=new ht(this.pool.token0,this.pool.token1,this.pool.fee,i,0,Q.getTickAtSqrtRatio(i)),u=new t({pool:new ht(this.pool.token0,this.pool.token1,this.pool.fee,r,0,Q.getTickAtSqrtRatio(r)),liquidity:this.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).amount0,a=new t({pool:o,liquidity:this.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).amount1;return{amount0:u.quotient,amount1:a.quotient}},t.fromAmounts=function(e){var n=e.pool,r=e.tickLower,i=e.tickUpper,o=e.amount0,u=e.amount1,a=e.useFullPrecision,c=Q.getSqrtRatioAtTick(r),s=Q.getSqrtRatioAtTick(i);return new t({pool:n,tickLower:r,tickUpper:i,liquidity:it(n.sqrtRatioX96,c,s,o,u,a)})},t.fromAmount0=function(n){return t.fromAmounts({pool:n.pool,tickLower:n.tickLower,tickUpper:n.tickUpper,amount0:n.amount0,amount1:e.MaxUint256,useFullPrecision:n.useFullPrecision})},t.fromAmount1=function(n){return t.fromAmounts({pool:n.pool,tickLower:n.tickLower,tickUpper:n.tickUpper,amount0:e.MaxUint256,amount1:n.amount1,useFullPrecision:!0})},y(t,[{key:"token0PriceLower",get:function(){return at(this.pool.token0,this.pool.token1,this.tickLower)}},{key:"token0PriceUpper",get:function(){return at(this.pool.token0,this.pool.token1,this.tickUpper)}},{key:"amount0",get:function(){return null===this._token0Amount&&(this._token0Amount=e.CurrencyAmount.fromRawAmount(this.pool.token0,this.pool.tickCurrent<this.tickLower?B.getAmount0Delta(Q.getSqrtRatioAtTick(this.tickLower),Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1):this.pool.tickCurrent<this.tickUpper?B.getAmount0Delta(this.pool.sqrtRatioX96,Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1):C)),this._token0Amount}},{key:"amount1",get:function(){return null===this._token1Amount&&(this._token1Amount=e.CurrencyAmount.fromRawAmount(this.pool.token1,this.pool.tickCurrent<this.tickLower?C:B.getAmount1Delta(Q.getSqrtRatioAtTick(this.tickLower),this.pool.tickCurrent<this.tickUpper?this.pool.sqrtRatioX96:Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1))),this._token1Amount}},{key:"mintAmounts",get:function(){return null===this._mintAmounts?this.pool.tickCurrent<this.tickLower?{amount0:B.getAmount0Delta(Q.getSqrtRatioAtTick(this.tickLower),Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0),amount1:C}:this.pool.tickCurrent<this.tickUpper?{amount0:B.getAmount0Delta(this.pool.sqrtRatioX96,Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0),amount1:B.getAmount1Delta(Q.getSqrtRatioAtTick(this.tickLower),this.pool.sqrtRatioX96,this.liquidity,!0)}:{amount0:C,amount1:B.getAmount1Delta(Q.getSqrtRatioAtTick(this.tickLower),Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0)}:this._mintAmounts}}]),t}(),vt=function(){function t(t,e,n){this._midPrice=null,t.length>0||r(!1);var i=t[0].chainId;t.every((function(t){return t.chainId===i}))||r(!1);var o=e.wrapped;t[0].involvesToken(o)||r(!1),t[t.length-1].involvesToken(n.wrapped)||r(!1);for(var u,a=[o],c=T(t.entries());!(u=c()).done;){var s=u.value,p=s[1],l=a[s[0]];l.equals(p.token0)||l.equals(p.token1)||r(!1);var d=l.equals(p.token0)?p.token1:p.token0;a.push(d)}this.pools=t,this.tokenPath=a,this.input=e,this.output=null!=n?n:a[a.length-1]}return y(t,[{key:"chainId",get:function(){return this.pools[0].chainId}},{key:"midPrice",get:function(){if(null!==this._midPrice)return this._midPrice;var t=this.pools.slice(1).reduce((function(t,e){var n=t.price;return t.nextInput.equals(e.token0)?{nextInput:e.token1,price:n.multiply(e.token0Price)}:{nextInput:e.token0,price:n.multiply(e.token1Price)}}),this.pools[0].token0.equals(this.input.wrapped)?{nextInput:this.pools[0].token1,price:this.pools[0].token0Price}:{nextInput:this.pools[0].token0,price:this.pools[0].token1Price}).price;return this._midPrice=new e.Price(this.input,this.output,t.denominator,t.numerator)}}]),t}();function kt(t,e){return t.inputAmount.currency.equals(e.inputAmount.currency)||r(!1),t.outputAmount.currency.equals(e.outputAmount.currency)||r(!1),t.outputAmount.equalTo(e.outputAmount)?t.inputAmount.equalTo(e.inputAmount)?t.swaps.reduce((function(t,e){return t+e.route.tokenPath.length}),0)-e.swaps.reduce((function(t,e){return t+e.route.tokenPath.length}),0):t.inputAmount.lessThan(e.inputAmount)?-1:1:t.outputAmount.lessThan(e.outputAmount)?1:-1}var yt=function(){function t(t){var e=t.routes,n=t.tradeType,i=e[0].inputAmount.currency,o=e[0].outputAmount.currency;e.every((function(t){return i.wrapped.equals(t.route.input.wrapped)}))||r(!1),e.every((function(t){return o.wrapped.equals(t.route.output.wrapped)}))||r(!1);for(var u,a=e.map((function(t){return t.route.pools.length})).reduce((function(t,e){return t+e}),0),c=new Set,s=T(e);!(u=s()).done;)for(var p,l=T(u.value.route.pools);!(p=l()).done;){var d=p.value;c.add(ht.getAddress(d.token0,d.token1,d.fee))}a!=c.size&&r(!1),this.swaps=e,this.tradeType=n}t.exactIn=function(){var n=v(q.mark((function n(r,i){return q.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.abrupt("return",t.fromRoute(r,i,e.TradeType.EXACT_INPUT));case 1:case"end":return n.stop()}}),n)})));return function(t,e){return n.apply(this,arguments)}}(),t.exactOut=function(){var n=v(q.mark((function n(r,i){return q.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.abrupt("return",t.fromRoute(r,i,e.TradeType.EXACT_OUTPUT));case 1:case"end":return n.stop()}}),n)})));return function(t,e){return n.apply(this,arguments)}}(),t.fromRoute=function(){var n=v(q.mark((function n(i,o,u){var a,c,s,p,l,d,f;return q.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(a=new Array(i.tokenPath.length),u!==e.TradeType.EXACT_INPUT){n.next=19;break}o.currency.equals(i.input)||r(!1),a[0]=o.wrapped,p=0;case 5:if(!(p<i.tokenPath.length-1)){n.next=15;break}return l=i.pools[p],n.next=9,l.getOutputAmount(a[p]);case 9:a[p+1]=n.sent[0];case 12:p++,n.next=5;break;case 15:c=e.CurrencyAmount.fromFractionalAmount(i.input,o.numerator,o.denominator),s=e.CurrencyAmount.fromFractionalAmount(i.output,a[a.length-1].numerator,a[a.length-1].denominator),n.next=34;break;case 19:o.currency.equals(i.output)||r(!1),a[a.length-1]=o.wrapped,d=i.tokenPath.length-1;case 22:if(!(d>0)){n.next=32;break}return f=i.pools[d-1],n.next=26,f.getInputAmount(a[d]);case 26:a[d-1]=n.sent[0];case 29:d--,n.next=22;break;case 32:c=e.CurrencyAmount.fromFractionalAmount(i.input,a[0].numerator,a[0].denominator),s=e.CurrencyAmount.fromFractionalAmount(i.output,o.numerator,o.denominator);case 34:return n.abrupt("return",new t({routes:[{inputAmount:c,outputAmount:s,route:i}],tradeType:u}));case 35:case"end":return n.stop()}}),n)})));return function(t,e,r){return n.apply(this,arguments)}}(),t.fromRoutes=function(){var n=v(q.mark((function n(i,o){var u,a,c,s,p,l,d,f,h,m,v,k,y;return q.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:u=[],a=T(i);case 2:if((c=a()).done){n.next=43;break}if(p=(s=c.value).route,l=s.amount,d=new Array(p.tokenPath.length),f=void 0,h=void 0,o!==e.TradeType.EXACT_INPUT){n.next=25;break}l.currency.equals(p.input)||r(!1),f=e.CurrencyAmount.fromFractionalAmount(p.input,l.numerator,l.denominator),d[0]=e.CurrencyAmount.fromFractionalAmount(p.input.wrapped,l.numerator,l.denominator),m=0;case 12:if(!(m<p.tokenPath.length-1)){n.next=22;break}return v=p.pools[m],n.next=16,v.getOutputAmount(d[m]);case 16:d[m+1]=n.sent[0];case 19:m++,n.next=12;break;case 22:h=e.CurrencyAmount.fromFractionalAmount(p.output,d[d.length-1].numerator,d[d.length-1].denominator),n.next=40;break;case 25:l.currency.equals(p.output)||r(!1),h=e.CurrencyAmount.fromFractionalAmount(p.output,l.numerator,l.denominator),d[d.length-1]=e.CurrencyAmount.fromFractionalAmount(p.output.wrapped,l.numerator,l.denominator),k=p.tokenPath.length-1;case 29:if(!(k>0)){n.next=39;break}return y=p.pools[k-1],n.next=33,y.getInputAmount(d[k]);case 33:d[k-1]=n.sent[0];case 36:k--,n.next=29;break;case 39:f=e.CurrencyAmount.fromFractionalAmount(p.input,d[0].numerator,d[0].denominator);case 40:u.push({route:p,inputAmount:f,outputAmount:h});case 41:n.next=2;break;case 43:return n.abrupt("return",new t({routes:u,tradeType:o}));case 44:case"end":return n.stop()}}),n)})));return function(t,e){return n.apply(this,arguments)}}(),t.createUncheckedTrade=function(e){return new t(g({},e,{routes:[{inputAmount:e.inputAmount,outputAmount:e.outputAmount,route:e.route}]}))},t.createUncheckedTradeWithMultipleRoutes=function(e){return new t(e)};var n=t.prototype;return n.minimumAmountOut=function(t,n){if(void 0===n&&(n=this.outputAmount),t.lessThan(C)&&r(!1),this.tradeType===e.TradeType.EXACT_OUTPUT)return n;var i=new e.Fraction(S).add(t).invert().multiply(n.quotient).quotient;return e.CurrencyAmount.fromRawAmount(n.currency,i)},n.maximumAmountIn=function(t,n){if(void 0===n&&(n=this.inputAmount),t.lessThan(C)&&r(!1),this.tradeType===e.TradeType.EXACT_INPUT)return n;var i=new e.Fraction(S).add(t).multiply(n.quotient).quotient;return e.CurrencyAmount.fromRawAmount(n.currency,i)},n.worstExecutionPrice=function(t){return new e.Price(this.inputAmount.currency,this.outputAmount.currency,this.maximumAmountIn(t).quotient,this.minimumAmountOut(t).quotient)},t.bestTradeExactIn=function(){var n=v(q.mark((function n(i,o,u,a,c,s,p){var l,d,f,h,m,v,k,y,g,A,T;return q.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:f=void 0===(d=(l=void 0===a?{}:a).maxNumResults)?3:d,m=void 0===(h=l.maxHops)?3:h,void 0===c&&(c=[]),void 0===s&&(s=o),void 0===p&&(p=[]),i.length>0||r(!1),m>0||r(!1),o===s||c.length>0||r(!1),v=s.wrapped,k=u.wrapped,y=0;case 10:if(!(y<i.length)){n.next=46;break}if((g=i[y]).token0.equals(v.currency)||g.token1.equals(v.currency)){n.next=14;break}return n.abrupt("continue",43);case 14:return A=void 0,n.prev=15,n.next=19,g.getOutputAmount(v);case 19:A=n.sent[0],n.next=28;break;case 23:if(n.prev=23,n.t0=n.catch(15),!n.t0.isInsufficientInputAmountError){n.next=27;break}return n.abrupt("continue",43);case 27:throw n.t0;case 28:if(!A.currency.isToken||!A.currency.equals(k)){n.next=39;break}return n.t1=e.sortedInsert,n.t2=p,n.next=33,t.fromRoute(new vt([].concat(c,[g]),o.currency,u),o,e.TradeType.EXACT_INPUT);case 33:n.t3=n.sent,n.t4=f,n.t5=kt,(0,n.t1)(n.t2,n.t3,n.t4,n.t5),n.next=43;break;case 39:if(!(m>1&&i.length>1)){n.next=43;break}return T=i.slice(0,y).concat(i.slice(y+1,i.length)),n.next=43,t.bestTradeExactIn(T,o,u,{maxNumResults:f,maxHops:m-1},[].concat(c,[g]),A,p);case 43:y++,n.next=10;break;case 46:return n.abrupt("return",p);case 47:case"end":return n.stop()}}),n,null,[[15,23]])})));return function(t,e,r,i,o,u,a){return n.apply(this,arguments)}}(),t.bestTradeExactOut=function(){var n=v(q.mark((function n(i,o,u,a,c,s,p){var l,d,f,h,m,v,k,y,g,A,T;return q.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:f=void 0===(d=(l=void 0===a?{}:a).maxNumResults)?3:d,m=void 0===(h=l.maxHops)?3:h,void 0===c&&(c=[]),void 0===s&&(s=u),void 0===p&&(p=[]),i.length>0||r(!1),m>0||r(!1),u===s||c.length>0||r(!1),v=s.wrapped,k=o.wrapped,y=0;case 10:if(!(y<i.length)){n.next=46;break}if((g=i[y]).token0.equals(v.currency)||g.token1.equals(v.currency)){n.next=14;break}return n.abrupt("continue",43);case 14:return A=void 0,n.prev=15,n.next=19,g.getInputAmount(v);case 19:A=n.sent[0],n.next=28;break;case 23:if(n.prev=23,n.t0=n.catch(15),!n.t0.isInsufficientReservesError){n.next=27;break}return n.abrupt("continue",43);case 27:throw n.t0;case 28:if(!A.currency.equals(k)){n.next=39;break}return n.t1=e.sortedInsert,n.t2=p,n.next=33,t.fromRoute(new vt([g].concat(c),o,u.currency),u,e.TradeType.EXACT_OUTPUT);case 33:n.t3=n.sent,n.t4=f,n.t5=kt,(0,n.t1)(n.t2,n.t3,n.t4,n.t5),n.next=43;break;case 39:if(!(m>1&&i.length>1)){n.next=43;break}return T=i.slice(0,y).concat(i.slice(y+1,i.length)),n.next=43,t.bestTradeExactOut(T,o,u,{maxNumResults:f,maxHops:m-1},[g].concat(c),A,p);case 43:y++,n.next=10;break;case 46:return n.abrupt("return",p);case 47:case"end":return n.stop()}}),n,null,[[15,23]])})));return function(t,e,r,i,o,u,a){return n.apply(this,arguments)}}(),y(t,[{key:"route",get:function(){return 1!=this.swaps.length&&r(!1),this.swaps[0].route}},{key:"inputAmount",get:function(){if(this._inputAmount)return this._inputAmount;var t=this.swaps[0].inputAmount.currency,n=this.swaps.map((function(t){return t.inputAmount})).reduce((function(t,e){return t.add(e)}),e.CurrencyAmount.fromRawAmount(t,0));return this._inputAmount=n,this._inputAmount}},{key:"outputAmount",get:function(){if(this._outputAmount)return this._outputAmount;var t=this.swaps[0].outputAmount.currency,n=this.swaps.map((function(t){return t.outputAmount})).reduce((function(t,e){return t.add(e)}),e.CurrencyAmount.fromRawAmount(t,0));return this._outputAmount=n,this._outputAmount}},{key:"executionPrice",get:function(){var t;return null!=(t=this._executionPrice)?t:this._executionPrice=new e.Price(this.inputAmount.currency,this.outputAmount.currency,this.inputAmount.quotient,this.outputAmount.quotient)}},{key:"priceImpact",get:function(){if(this._priceImpact)return this._priceImpact;for(var t,n=e.CurrencyAmount.fromRawAmount(this.outputAmount.currency,0),r=T(this.swaps);!(t=r()).done;){var i=t.value;n=n.add(i.route.midPrice.quote(i.inputAmount))}var o=n.subtract(this.outputAmount).divide(n);return this._priceImpact=new e.Percent(o.numerator,o.denominator),this._priceImpact}}]),t}(),gt=function(){function t(){}return t.encodeMulticall=function(e){return Array.isArray(e)||(e=[e]),1===e.length?e[0]:t.INTERFACE.encodeFunctionData("multicall",[e])},t}();gt.INTERFACE=new i.Interface(a.abi);var At=function(){function t(){}return t.encodePermit=function(e,n){return"nonce"in n?t.INTERFACE.encodeFunctionData("selfPermitAllowed",[e.address,$(n.nonce),$(n.expiry),n.v,n.r,n.s]):t.INTERFACE.encodeFunctionData("selfPermit",[e.address,$(n.amount),$(n.deadline),n.v,n.r,n.s])},t}();At.INTERFACE=new i.Interface(s.abi);var Tt=function(){function t(){}return t.encodeFeeBips=function(t){return $(t.multiply(1e4).quotient)},t.encodeUnwrapWETH9=function(n,r,i){if(r=e.validateAndParseAddress(r),i){var o=this.encodeFeeBips(i.fee),u=e.validateAndParseAddress(i.recipient);return t.INTERFACE.encodeFunctionData("unwrapWETH9WithFee",[$(n),r,o,u])}return t.INTERFACE.encodeFunctionData("unwrapWETH9",[$(n),r])},t.encodeSweepToken=function(n,r,i,o){if(i=e.validateAndParseAddress(i),o){var u=this.encodeFeeBips(o.fee),a=e.validateAndParseAddress(o.recipient);return t.INTERFACE.encodeFunctionData("sweepTokenWithFee",[n.address,$(r),i,u,a])}return t.INTERFACE.encodeFunctionData("sweepToken",[n.address,$(r),i])},t.encodeRefundETH=function(){return t.INTERFACE.encodeFunctionData("refundETH")},t}();Tt.INTERFACE=new i.Interface(p.abi);var xt=$(n.subtract(n.exponentiate(n.BigInt(2),n.BigInt(128)),n.BigInt(1)));function wt(t){return Object.keys(t).some((function(t){return"recipient"===t}))}var It=function(){function t(){}return t.encodeCreate=function(e){return t.INTERFACE.encodeFunctionData("createAndInitializePoolIfNecessary",[e.token0.address,e.token1.address,e.fee,$(e.sqrtRatioX96)])},t.createCallParameters=function(t){return{calldata:this.encodeCreate(t),value:$(0)}},t.addCallParameters=function(i,o){n.greaterThan(i.liquidity,C)||r(!1);var u=[],a=i.mintAmounts,c=a.amount0,s=a.amount1,p=i.mintAmountsWithSlippage(o.slippageTolerance),l=$(p.amount0),d=$(p.amount1),f=$(o.deadline);if(wt(o)&&o.createPool&&u.push(this.encodeCreate(i.pool)),o.token0Permit&&u.push(At.encodePermit(i.pool.token0,o.token0Permit)),o.token1Permit&&u.push(At.encodePermit(i.pool.token1,o.token1Permit)),wt(o)){var h=e.validateAndParseAddress(o.recipient);u.push(t.INTERFACE.encodeFunctionData("mint",[{token0:i.pool.token0.address,token1:i.pool.token1.address,fee:i.pool.fee,tickLower:i.tickLower,tickUpper:i.tickUpper,amount0Desired:$(c),amount1Desired:$(s),amount0Min:l,amount1Min:d,recipient:h,deadline:f}]))}else u.push(t.INTERFACE.encodeFunctionData("increaseLiquidity",[{tokenId:$(o.tokenId),amount0Desired:$(c),amount1Desired:$(s),amount0Min:l,amount1Min:d,deadline:f}]));var m=$(0);if(o.useNative){var v=o.useNative.wrapped;i.pool.token0.equals(v)||i.pool.token1.equals(v)||r(!1);var k=i.pool.token0.equals(v)?c:s;n.greaterThan(k,C)&&u.push(Tt.encodeRefundETH()),m=$(k)}return{calldata:gt.encodeMulticall(u),value:m}},t.encodeCollect=function(n){var r=[],i=$(n.tokenId),o=n.expectedCurrencyOwed0.currency.isNative||n.expectedCurrencyOwed1.currency.isNative,u=e.validateAndParseAddress(n.recipient);if(r.push(t.INTERFACE.encodeFunctionData("collect",[{tokenId:i,recipient:o?b:u,amount0Max:xt,amount1Max:xt}])),o){var a=n.expectedCurrencyOwed0.currency.isNative?n.expectedCurrencyOwed1.currency:n.expectedCurrencyOwed0.currency,c=n.expectedCurrencyOwed0.currency.isNative?n.expectedCurrencyOwed1.quotient:n.expectedCurrencyOwed0.quotient;r.push(Tt.encodeUnwrapWETH9(n.expectedCurrencyOwed0.currency.isNative?n.expectedCurrencyOwed0.quotient:n.expectedCurrencyOwed1.quotient,u)),r.push(Tt.encodeSweepToken(a,c,u))}return r},t.collectCallParameters=function(e){var n=t.encodeCollect(e);return{calldata:gt.encodeMulticall(n),value:$(0)}},t.removeCallParameters=function(i,o){var u=[],a=$(o.deadline),c=$(o.tokenId),s=new mt({pool:i.pool,liquidity:o.liquidityPercentage.multiply(i.liquidity).quotient,tickLower:i.tickLower,tickUpper:i.tickUpper});n.greaterThan(s.liquidity,C)||r(!1);var p=s.burnAmountsWithSlippage(o.slippageTolerance),l=p.amount0,d=p.amount1;o.permit&&u.push(t.INTERFACE.encodeFunctionData("permit",[e.validateAndParseAddress(o.permit.spender),c,$(o.permit.deadline),o.permit.v,o.permit.r,o.permit.s])),u.push(t.INTERFACE.encodeFunctionData("decreaseLiquidity",[{tokenId:c,liquidity:$(s.liquidity),amount0Min:$(l),amount1Min:$(d),deadline:a}]));var f=o.collectOptions,h=f.expectedCurrencyOwed0,m=f.expectedCurrencyOwed1,v=function(t,e){if(null==t)return{};var n,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)e.indexOf(n=o[r])>=0||(i[n]=t[n]);return i}(f,["expectedCurrencyOwed0","expectedCurrencyOwed1"]);return u.push.apply(u,t.encodeCollect(g({tokenId:$(o.tokenId),expectedCurrencyOwed0:h.add(e.CurrencyAmount.fromRawAmount(h.currency,l)),expectedCurrencyOwed1:m.add(e.CurrencyAmount.fromRawAmount(m.currency,d))},v))),o.liquidityPercentage.equalTo(S)?o.burnToken&&u.push(t.INTERFACE.encodeFunctionData("burn",[c])):!0===o.burnToken&&r(!1),{calldata:gt.encodeMulticall(u),value:$(0)}},t.safeTransferFromParameters=function(n){var r=e.validateAndParseAddress(n.recipient),i=e.validateAndParseAddress(n.sender);return{calldata:n.data?t.INTERFACE.encodeFunctionData("safeTransferFrom(address,address,uint256,bytes)",[i,r,$(n.tokenId),n.data]):t.INTERFACE.encodeFunctionData("safeTransferFrom(address,address,uint256)",[i,r,$(n.tokenId)]),value:$(0)}},t}();It.INTERFACE=new i.Interface(c.abi);var qt=function(){function t(){}return t.quoteCallParameters=function(t,n,i,o){void 0===o&&(o={});var u,a=1===t.pools.length,c=$(n.quotient),s=o.useQuoterV2?this.V2INTERFACE:this.V1INTERFACE;if(a){var p,l,d={tokenIn:t.tokenPath[0].address,tokenOut:t.tokenPath[1].address,fee:t.pools[0].fee,sqrtPriceLimitX96:$(null!=(p=null==(l=o)?void 0:l.sqrtPriceLimitX96)?p:0)},f=g({},d,i==e.TradeType.EXACT_INPUT?{amountIn:c}:{amount:c});u=s.encodeFunctionData(i===e.TradeType.EXACT_INPUT?"quoteExactInputSingle":"quoteExactOutputSingle",o.useQuoterV2?[f]:[d.tokenIn,d.tokenOut,d.fee,c,d.sqrtPriceLimitX96])}else{var h;void 0!==(null==(h=o)?void 0:h.sqrtPriceLimitX96)&&r(!1);var m=J(t,i===e.TradeType.EXACT_OUTPUT);u=s.encodeFunctionData(i===e.TradeType.EXACT_INPUT?"quoteExactInput":"quoteExactOutput",[m,c])}return{calldata:u,value:$(0)}},t}();qt.V1INTERFACE=new i.Interface(l.abi),qt.V2INTERFACE=new i.Interface(d.abi);var bt=function(){function t(){}return t.encodeClaim=function(n,r){var i,o=[];o.push(t.INTERFACE.encodeFunctionData("unstakeToken",[this._encodeIncentiveKey(n),$(r.tokenId)]));var u=e.validateAndParseAddress(r.recipient),a=null!=(i=r.amount)?i:0;return o.push(t.INTERFACE.encodeFunctionData("claimReward",[n.rewardToken.address,u,$(a)])),o},t.collectRewards=function(e,n){e=Array.isArray(e)?e:[e];for(var r=[],i=0;i<e.length;i++){var o=e[i];(r=r.concat(this.encodeClaim(o,n))).push(t.INTERFACE.encodeFunctionData("stakeToken",[this._encodeIncentiveKey(o),$(n.tokenId)]))}return{calldata:gt.encodeMulticall(r),value:$(0)}},t.withdrawToken=function(n,r){var i=[];n=Array.isArray(n)?n:[n];for(var o={tokenId:r.tokenId,recipient:r.recipient,amount:r.amount},u=0;u<n.length;u++)i=i.concat(this.encodeClaim(n[u],o));var a=e.validateAndParseAddress(r.owner);return i.push(t.INTERFACE.encodeFunctionData("withdrawToken",[$(r.tokenId),a,r.data?r.data:$(0)])),{calldata:gt.encodeMulticall(i),value:$(0)}},t.encodeDeposit=function(e){var n;if((e=Array.isArray(e)?e:[e]).length>1){for(var r=[],o=0;o<e.length;o++)r.push(this._encodeIncentiveKey(e[o]));n=i.defaultAbiCoder.encode([t.INCENTIVE_KEY_ABI+"[]"],[r])}else n=i.defaultAbiCoder.encode([t.INCENTIVE_KEY_ABI],[this._encodeIncentiveKey(e[0])]);return n},t._encodeIncentiveKey=function(t){var n=t.pool,r=n.token0,i=n.token1,o=n.fee,u=e.validateAndParseAddress(t.refundee);return{rewardToken:t.rewardToken.address,pool:ht.getAddress(r,i,o),startTime:$(t.startTime),endTime:$(t.endTime),refundee:u}},t}();bt.INTERFACE=new i.Interface(f.abi),bt.INCENTIVE_KEY_ABI="tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)";var Rt=function(){function t(){}return t.swapCallParameters=function(n,i){Array.isArray(n)||(n=[n]);var o=n[0],u=o.inputAmount.currency.wrapped,a=o.outputAmount.currency.wrapped;n.every((function(t){return t.inputAmount.currency.wrapped.equals(u)}))||r(!1),n.every((function(t){return t.outputAmount.currency.wrapped.equals(a)}))||r(!1);var c=[],s=e.CurrencyAmount.fromRawAmount(n[0].inputAmount.currency,0),p=e.CurrencyAmount.fromRawAmount(n[0].outputAmount.currency,0),l=n.reduce((function(t,e){return t.add(e.minimumAmountOut(i.slippageTolerance))}),p),d=o.inputAmount.currency.isNative&&o.tradeType===e.TradeType.EXACT_OUTPUT,f=o.outputAmount.currency.isNative,h=f||!!i.fee,m=o.inputAmount.currency.isNative?n.reduce((function(t,e){return t.add(e.maximumAmountIn(i.slippageTolerance))}),s):s;i.inputTokenPermit&&(o.inputAmount.currency.isToken||r(!1),c.push(At.encodePermit(o.inputAmount.currency,i.inputTokenPermit)));for(var v,k=e.validateAndParseAddress(i.recipient),y=$(i.deadline),g=T(n);!(v=g()).done;)for(var A,x=v.value,w=T(x.swaps);!(A=w()).done;){var I=A.value,q=I.route,R=I.outputAmount,E=$(x.maximumAmountIn(i.slippageTolerance,I.inputAmount).quotient),P=$(x.minimumAmountOut(i.slippageTolerance,R).quotient);if(1===q.pools.length)if(x.tradeType===e.TradeType.EXACT_INPUT){var C,S={tokenIn:q.tokenPath[0].address,tokenOut:q.tokenPath[1].address,fee:q.pools[0].fee,recipient:h?b:k,deadline:y,amountIn:E,amountOutMinimum:P,sqrtPriceLimitX96:$(null!=(C=i.sqrtPriceLimitX96)?C:0)};c.push(t.INTERFACE.encodeFunctionData("exactInputSingle",[S]))}else{var O,N={tokenIn:q.tokenPath[0].address,tokenOut:q.tokenPath[1].address,fee:q.pools[0].fee,recipient:h?b:k,deadline:y,amountOut:P,amountInMaximum:E,sqrtPriceLimitX96:$(null!=(O=i.sqrtPriceLimitX96)?O:0)};c.push(t.INTERFACE.encodeFunctionData("exactOutputSingle",[N]))}else{void 0!==i.sqrtPriceLimitX96&&r(!1);var _=J(q,x.tradeType===e.TradeType.EXACT_OUTPUT);c.push(x.tradeType===e.TradeType.EXACT_INPUT?t.INTERFACE.encodeFunctionData("exactInput",[{path:_,recipient:h?b:k,deadline:y,amountIn:E,amountOutMinimum:P}]):t.INTERFACE.encodeFunctionData("exactOutput",[{path:_,recipient:h?b:k,deadline:y,amountOut:P,amountInMaximum:E}]))}}return h&&c.push(i.fee?f?Tt.encodeUnwrapWETH9(l.quotient,k,i.fee):Tt.encodeSweepToken(o.outputAmount.currency.wrapped,l.quotient,k,i.fee):Tt.encodeUnwrapWETH9(l.quotient,k)),d&&c.push(Tt.encodeRefundETH()),{calldata:gt.encodeMulticall(c),value:$(m.quotient)}},t}();Rt.INTERFACE=new i.Interface(h.abi),exports.ADDRESS_ZERO=b,exports.FACTORY_ADDRESS="0x1F98431c8aD98523631AE4a59f267346ea31F984",exports.FullMath=X,exports.LiquidityMath=F,exports.Multicall=gt,exports.NoTickDataProvider=V,exports.NonfungiblePositionManager=It,exports.POOL_INIT_CODE_HASH=R,exports.Payments=Tt,exports.Pool=ht,exports.Position=mt,exports.PositionLibrary=ut,exports.Route=vt,exports.SelfPermit=At,exports.SqrtPriceMath=B,exports.Staker=bt,exports.SwapMath=D,exports.SwapQuoter=qt,exports.SwapRouter=Rt,exports.TICK_SPACINGS=E,exports.Tick=lt,exports.TickLibrary=pt,exports.TickList=Z,exports.TickListDataProvider=dt,exports.TickMath=Q,exports.Trade=yt,exports.computePoolAddress=_,exports.encodeRouteToPath=J,exports.encodeSqrtRatioX96=tt,exports.isSorted=z,exports.maxLiquidityForAmounts=it,exports.mostSignificantBit=G,exports.nearestUsableTick=function(t,e){Number.isInteger(t)&&Number.isInteger(e)||r(!1),e>0||r(!1),t>=Q.MIN_TICK&&t<=Q.MAX_TICK||r(!1);var n=Math.round(t/e)*e;return n<Q.MIN_TICK?n+e:n>Q.MAX_TICK?n-e:n},exports.priceToClosestTick=function(t){var e=t.baseCurrency.sortsBefore(t.quoteCurrency),n=e?tt(t.numerator,t.denominator):tt(t.denominator,t.numerator),r=Q.getTickAtSqrtRatio(n),i=at(t.baseCurrency,t.quoteCurrency,r+1);return e?t.lessThan(i)||r++:t.greaterThan(i)||r++,r},exports.subIn256=st,exports.tickToPrice=at,exports.toHex=$,exports.tradeComparator=kt;
+"use strict";function t(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var e,n=require("@uniswap/sdk-core"),r=t(require("jsbi")),i=t(require("tiny-invariant")),o=require("@ethersproject/abi"),u=require("@ethersproject/address"),a=require("@ethersproject/solidity"),c=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/IMulticall.sol/IMulticall.json")),s=t(require("@uniswap/v3-periphery/artifacts/contracts/NonfungiblePositionManager.sol/NonfungiblePositionManager.json")),p=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/ISelfPermit.sol/ISelfPermit.json")),l=t(require("@uniswap/v3-periphery/artifacts/contracts/interfaces/IPeripheryPaymentsWithFee.sol/IPeripheryPaymentsWithFee.json")),d=t(require("@uniswap/v3-periphery/artifacts/contracts/lens/Quoter.sol/Quoter.json")),f=t(require("@uniswap/swap-router-contracts/artifacts/contracts/lens/QuoterV2.sol/QuoterV2.json")),h=t(require("@uniswap/v3-staker/artifacts/contracts/UniswapV3Staker.sol/UniswapV3Staker.json")),m=t(require("@uniswap/v3-periphery/artifacts/contracts/SwapRouter.sol/SwapRouter.json"));function v(){v=function(){return e};var t,e={},n=Object.prototype,r=n.hasOwnProperty,i=Object.defineProperty||function(t,e,n){t[e]=n.value},o="function"==typeof Symbol?Symbol:{},u=o.iterator||"@@iterator",a=o.asyncIterator||"@@asyncIterator",c=o.toStringTag||"@@toStringTag";function s(t,e,n){return Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{s({},"")}catch(t){s=function(t,e,n){return t[e]=n}}function p(t,e,n,r){var o=Object.create((e&&e.prototype instanceof y?e:y).prototype),u=new C(r||[]);return i(o,"_invoke",{value:b(t,n,u)}),o}function l(t,e,n){try{return{type:"normal",arg:t.call(e,n)}}catch(t){return{type:"throw",arg:t}}}e.wrap=p;var d="suspendedStart",f="executing",h="completed",m={};function y(){}function k(){}function g(){}var A={};s(A,u,(function(){return this}));var T=Object.getPrototypeOf,w=T&&T(T(O([])));w&&w!==n&&r.call(w,u)&&(A=w);var I=g.prototype=y.prototype=Object.create(A);function x(t){["next","throw","return"].forEach((function(e){s(t,e,(function(t){return this._invoke(e,t)}))}))}function q(t,e){function n(i,o,u,a){var c=l(t[i],t,o);if("throw"!==c.type){var s=c.arg,p=s.value;return p&&"object"==typeof p&&r.call(p,"__await")?e.resolve(p.__await).then((function(t){n("next",t,u,a)}),(function(t){n("throw",t,u,a)})):e.resolve(p).then((function(t){s.value=t,u(s)}),(function(t){return n("throw",t,u,a)}))}a(c.arg)}var o;i(this,"_invoke",{value:function(t,r){function i(){return new e((function(e,i){n(t,r,e,i)}))}return o=o?o.then(i,i):i()}})}function b(e,n,r){var i=d;return function(o,u){if(i===f)throw new Error("Generator is already running");if(i===h){if("throw"===o)throw u;return{value:t,done:!0}}for(r.method=o,r.arg=u;;){var a=r.delegate;if(a){var c=R(a,r);if(c){if(c===m)continue;return c}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(i===d)throw i=h,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);i=f;var s=l(e,n,r);if("normal"===s.type){if(i=r.done?h:"suspendedYield",s.arg===m)continue;return{value:s.arg,done:r.done}}"throw"===s.type&&(i=h,r.method="throw",r.arg=s.arg)}}}function R(e,n){var r=n.method,i=e.iterator[r];if(i===t)return n.delegate=null,"throw"===r&&e.iterator.return&&(n.method="return",n.arg=t,R(e,n),"throw"===n.method)||"return"!==r&&(n.method="throw",n.arg=new TypeError("The iterator does not provide a '"+r+"' method")),m;var o=l(i,e.iterator,n.arg);if("throw"===o.type)return n.method="throw",n.arg=o.arg,n.delegate=null,m;var u=o.arg;return u?u.done?(n[e.resultName]=u.value,n.next=e.nextLoc,"return"!==n.method&&(n.method="next",n.arg=t),n.delegate=null,m):u:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,m)}function E(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function P(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function C(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(E,this),this.reset(!0)}function O(e){if(e||""===e){var n=e[u];if(n)return n.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var i=-1,o=function n(){for(;++i<e.length;)if(r.call(e,i))return n.value=e[i],n.done=!1,n;return n.value=t,n.done=!0,n};return o.next=o}}throw new TypeError(typeof e+" is not iterable")}return k.prototype=g,i(I,"constructor",{value:g,configurable:!0}),i(g,"constructor",{value:k,configurable:!0}),k.displayName=s(g,c,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===k||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,g):(t.__proto__=g,s(t,c,"GeneratorFunction")),t.prototype=Object.create(I),t},e.awrap=function(t){return{__await:t}},x(q.prototype),s(q.prototype,a,(function(){return this})),e.AsyncIterator=q,e.async=function(t,n,r,i,o){void 0===o&&(o=Promise);var u=new q(p(t,n,r,i),o);return e.isGeneratorFunction(n)?u:u.next().then((function(t){return t.done?t.value:u.next()}))},x(I),s(I,c,"Generator"),s(I,u,(function(){return this})),s(I,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),n=[];for(var r in e)n.push(r);return n.reverse(),function t(){for(;n.length;){var r=n.pop();if(r in e)return t.value=r,t.done=!1,t}return t.done=!0,t}},e.values=O,C.prototype={constructor:C,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(P),!e)for(var n in this)"t"===n.charAt(0)&&r.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var n=this;function i(r,i){return a.type="throw",a.arg=e,n.next=r,i&&(n.method="next",n.arg=t),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var u=this.tryEntries[o],a=u.completion;if("root"===u.tryLoc)return i("end");if(u.tryLoc<=this.prev){var c=r.call(u,"catchLoc"),s=r.call(u,"finallyLoc");if(c&&s){if(this.prev<u.catchLoc)return i(u.catchLoc,!0);if(this.prev<u.finallyLoc)return i(u.finallyLoc)}else if(c){if(this.prev<u.catchLoc)return i(u.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<u.finallyLoc)return i(u.finallyLoc)}}}},abrupt:function(t,e){for(var n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var u=o?o.completion:{};return u.type=t,u.arg=e,o?(this.method="next",this.next=o.finallyLoc,m):this.complete(u)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),m},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.finallyLoc===t)return this.complete(n.completion,n.afterLoc),P(n),m}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var n=this.tryEntries[e];if(n.tryLoc===t){var r=n.completion;if("throw"===r.type){var i=r.arg;P(n)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,n,r){return this.delegate={iterator:O(e),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=t),m}},e}function y(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,"string");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==typeof e?e:String(e)}function k(t,e,n,r,i,o,u){try{var a=t[o](u),c=a.value}catch(t){return void n(t)}a.done?e(c):Promise.resolve(c).then(r,i)}function g(t){return function(){var e=this,n=arguments;return new Promise((function(r,i){var o=t.apply(e,n);function u(t){k(o,r,i,u,a,"next",t)}function a(t){k(o,r,i,u,a,"throw",t)}u(void 0)}))}}function A(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,y(r.key),r)}}function T(t,e,n){return e&&A(t.prototype,e),n&&A(t,n),Object.defineProperty(t,"prototype",{writable:!1}),t}function w(){return(w=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t}).apply(this,arguments)}function I(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}function x(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(n)return(n=n.call(t)).next.bind(n);if(Array.isArray(t)||(n=function(t,e){if(t){if("string"==typeof t)return I(t,void 0);var n=Object.prototype.toString.call(t).slice(8,-1);return"Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?I(t,void 0):void 0}}(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0;return function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var q,b="0x0000000000000000000000000000000000000000",R="0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54";(q=exports.FeeAmount||(exports.FeeAmount={}))[q.LOWEST=100]="LOWEST",q[q.LOW=500]="LOW",q[q.MEDIUM=3e3]="MEDIUM",q[q.HIGH=1e4]="HIGH";var E=((e={})[exports.FeeAmount.LOWEST]=1,e[exports.FeeAmount.LOW]=10,e[exports.FeeAmount.MEDIUM]=60,e[exports.FeeAmount.HIGH]=200,e),P=r.BigInt(-1),C=r.BigInt(0),O=r.BigInt(1),S=r.exponentiate(r.BigInt(2),r.BigInt(96)),N=r.exponentiate(S,r.BigInt(2));function _(t){var e=t.factoryAddress,n=t.tokenA,r=t.tokenB,i=t.fee,c=t.initCodeHashManualOverride,s=n.sortsBefore(r)?[n,r]:[r,n];return u.getCreate2Address(e,a.keccak256(["bytes"],[o.defaultAbiCoder.encode(["address","address","uint24"],[s[0].address,s[1].address,i])]),null!=c?c:R)}var F=function(){function t(){}return t.addDelta=function(t,e){return r.lessThan(e,C)?r.subtract(t,r.multiply(e,P)):r.add(t,e)},t}(),X=function(){function t(){}return t.mulDivRoundingUp=function(t,e,n){var i=r.multiply(t,e),o=r.divide(i,n);return r.notEqual(r.remainder(i,n),C)&&(o=r.add(o,O)),o},t}(),L=r.subtract(r.exponentiate(r.BigInt(2),r.BigInt(160)),O);function U(t,e){var i=r.multiply(t,e);return r.bitwiseAnd(i,n.MaxUint256)}var B=function(){function t(){}return t.getAmount0Delta=function(t,e,n,i){if(r.greaterThan(t,e)){var o=[e,t];t=o[0],e=o[1]}var u=r.leftShift(n,r.BigInt(96)),a=r.subtract(e,t);return i?X.mulDivRoundingUp(X.mulDivRoundingUp(u,a,e),O,t):r.divide(r.divide(r.multiply(u,a),e),t)},t.getAmount1Delta=function(t,e,n,i){if(r.greaterThan(t,e)){var o=[e,t];t=o[0],e=o[1]}return i?X.mulDivRoundingUp(n,r.subtract(e,t),S):r.divide(r.multiply(n,r.subtract(e,t)),S)},t.getNextSqrtPriceFromInput=function(t,e,n,o){return r.greaterThan(t,C)||i(!1),r.greaterThan(e,C)||i(!1),o?this.getNextSqrtPriceFromAmount0RoundingUp(t,e,n,!0):this.getNextSqrtPriceFromAmount1RoundingDown(t,e,n,!0)},t.getNextSqrtPriceFromOutput=function(t,e,n,o){return r.greaterThan(t,C)||i(!1),r.greaterThan(e,C)||i(!1),o?this.getNextSqrtPriceFromAmount1RoundingDown(t,e,n,!1):this.getNextSqrtPriceFromAmount0RoundingUp(t,e,n,!1)},t.getNextSqrtPriceFromAmount0RoundingUp=function(t,e,o,u){if(r.equal(o,C))return t;var a=r.leftShift(e,r.BigInt(96));if(u){var c=U(o,t);if(r.equal(r.divide(c,o),t)){var s=(l=r.add(a,c),r.bitwiseAnd(l,n.MaxUint256));if(r.greaterThanOrEqual(s,a))return X.mulDivRoundingUp(a,t,s)}return X.mulDivRoundingUp(a,O,r.add(r.divide(a,t),o))}var p=U(o,t);r.equal(r.divide(p,o),t)||i(!1),r.greaterThan(a,p)||i(!1);var l,d=r.subtract(a,p);return X.mulDivRoundingUp(a,t,d)},t.getNextSqrtPriceFromAmount1RoundingDown=function(t,e,n,o){if(o){var u=r.lessThanOrEqual(n,L)?r.divide(r.leftShift(n,r.BigInt(96)),e):r.divide(r.multiply(n,S),e);return r.add(t,u)}var a=X.mulDivRoundingUp(n,S,e);return r.greaterThan(t,a)||i(!1),r.subtract(t,a)},t}(),M=r.exponentiate(r.BigInt(10),r.BigInt(6)),D=function(){function t(){}return t.computeSwapStep=function(t,e,n,i,o){var u={},a=r.greaterThanOrEqual(t,e),c=r.greaterThanOrEqual(i,C);if(c){var s=r.divide(r.multiply(i,r.subtract(M,r.BigInt(o))),M);u.amountIn=a?B.getAmount0Delta(e,t,n,!0):B.getAmount1Delta(t,e,n,!0),u.sqrtRatioNextX96=r.greaterThanOrEqual(s,u.amountIn)?e:B.getNextSqrtPriceFromInput(t,n,s,a)}else u.amountOut=a?B.getAmount1Delta(e,t,n,!1):B.getAmount0Delta(t,e,n,!1),u.sqrtRatioNextX96=r.greaterThanOrEqual(r.multiply(i,P),u.amountOut)?e:B.getNextSqrtPriceFromOutput(t,n,r.multiply(i,P),a);var p=r.equal(e,u.sqrtRatioNextX96);return a?(u.amountIn=p&&c?u.amountIn:B.getAmount0Delta(u.sqrtRatioNextX96,t,n,!0),u.amountOut=p&&!c?u.amountOut:B.getAmount1Delta(u.sqrtRatioNextX96,t,n,!1)):(u.amountIn=p&&c?u.amountIn:B.getAmount1Delta(t,u.sqrtRatioNextX96,n,!0),u.amountOut=p&&!c?u.amountOut:B.getAmount0Delta(t,u.sqrtRatioNextX96,n,!1)),!c&&r.greaterThan(u.amountOut,r.multiply(i,P))&&(u.amountOut=r.multiply(i,P)),u.feeAmount=c&&r.notEqual(u.sqrtRatioNextX96,e)?r.subtract(i,u.amountIn):X.mulDivRoundingUp(u.amountIn,r.BigInt(o),r.subtract(M,r.BigInt(o))),[u.sqrtRatioNextX96,u.amountIn,u.amountOut,u.feeAmount]},t}(),j=r.BigInt(2),W=[128,64,32,16,8,4,2,1].map((function(t){return[t,r.exponentiate(j,r.BigInt(t))]}));function G(t){r.greaterThan(t,C)||i(!1),r.lessThanOrEqual(t,n.MaxUint256)||i(!1);for(var e,o=0,u=x(W);!(e=u()).done;){var a=e.value,c=a[0];r.greaterThanOrEqual(t,a[1])&&(t=r.signedRightShift(t,r.BigInt(c)),o+=c)}return o}function K(t,e){return r.signedRightShift(r.multiply(t,r.BigInt(e)),r.BigInt(128))}var H=r.exponentiate(r.BigInt(2),r.BigInt(32)),Q=function(){function t(){}return t.getSqrtRatioAtTick=function(e){e>=t.MIN_TICK&&e<=t.MAX_TICK&&Number.isInteger(e)||i(!1);var o=e<0?-1*e:e,u=r.BigInt(0!=(1&o)?"0xfffcb933bd6fad37aa2d162d1a594001":"0x100000000000000000000000000000000");return 0!=(2&o)&&(u=K(u,"0xfff97272373d413259a46990580e213a")),0!=(4&o)&&(u=K(u,"0xfff2e50f5f656932ef12357cf3c7fdcc")),0!=(8&o)&&(u=K(u,"0xffe5caca7e10e4e61c3624eaa0941cd0")),0!=(16&o)&&(u=K(u,"0xffcb9843d60f6159c9db58835c926644")),0!=(32&o)&&(u=K(u,"0xff973b41fa98c081472e6896dfb254c0")),0!=(64&o)&&(u=K(u,"0xff2ea16466c96a3843ec78b326b52861")),0!=(128&o)&&(u=K(u,"0xfe5dee046a99a2a811c461f1969c3053")),0!=(256&o)&&(u=K(u,"0xfcbe86c7900a88aedcffc83b479aa3a4")),0!=(512&o)&&(u=K(u,"0xf987a7253ac413176f2b074cf7815e54")),0!=(1024&o)&&(u=K(u,"0xf3392b0822b70005940c7a398e4b70f3")),0!=(2048&o)&&(u=K(u,"0xe7159475a2c29b7443b29c7fa6e889d9")),0!=(4096&o)&&(u=K(u,"0xd097f3bdfd2022b8845ad8f792aa5825")),0!=(8192&o)&&(u=K(u,"0xa9f746462d870fdf8a65dc1f90e061e5")),0!=(16384&o)&&(u=K(u,"0x70d869a156d2a1b890bb3df62baf32f7")),0!=(32768&o)&&(u=K(u,"0x31be135f97d08fd981231505542fcfa6")),0!=(65536&o)&&(u=K(u,"0x9aa508b5b7a84e1c677de54f3e99bc9")),0!=(131072&o)&&(u=K(u,"0x5d6af8dedb81196699c329225ee604")),0!=(262144&o)&&(u=K(u,"0x2216e584f5fa1ea926041bedfe98")),0!=(524288&o)&&(u=K(u,"0x48a170391f7dc42444e8fa2")),e>0&&(u=r.divide(n.MaxUint256,u)),r.greaterThan(r.remainder(u,H),C)?r.add(r.divide(u,H),O):r.divide(u,H)},t.getTickAtSqrtRatio=function(e){r.greaterThanOrEqual(e,t.MIN_SQRT_RATIO)&&r.lessThan(e,t.MAX_SQRT_RATIO)||i(!1);var n,o=r.leftShift(e,r.BigInt(32)),u=G(o);n=r.greaterThanOrEqual(r.BigInt(u),r.BigInt(128))?r.signedRightShift(o,r.BigInt(u-127)):r.leftShift(o,r.BigInt(127-u));for(var a=r.leftShift(r.subtract(r.BigInt(u),r.BigInt(128)),r.BigInt(64)),c=0;c<14;c++){n=r.signedRightShift(r.multiply(n,n),r.BigInt(127));var s=r.signedRightShift(n,r.BigInt(128));a=r.bitwiseOr(a,r.leftShift(s,r.BigInt(63-c))),n=r.signedRightShift(n,s)}var p=r.multiply(a,r.BigInt("255738958999603826347141")),l=r.toNumber(r.signedRightShift(r.subtract(p,r.BigInt("3402992956809132418596140100660247210")),r.BigInt(128))),d=r.toNumber(r.signedRightShift(r.add(p,r.BigInt("291339464771989622907027621153398088495")),r.BigInt(128)));return l===d?l:r.lessThanOrEqual(t.getSqrtRatioAtTick(d),e)?d:l},t}();Q.MIN_TICK=-887272,Q.MAX_TICK=-Q.MIN_TICK,Q.MIN_SQRT_RATIO=r.BigInt("4295128739"),Q.MAX_SQRT_RATIO=r.BigInt("1461446703485210103287273052203988822378723970342");var V=function(){function t(){}var e=t.prototype;return e.getTick=function(){var e=g(v().mark((function e(n){return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:throw new Error(t.ERROR_MESSAGE);case 1:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),e.nextInitializedTickWithinOneWord=function(){var e=g(v().mark((function e(n,r,i){return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:throw new Error(t.ERROR_MESSAGE);case 1:case"end":return e.stop()}}),e)})));return function(t,n,r){return e.apply(this,arguments)}}(),t}();function z(t,e){for(var n=0;n<t.length-1;n++)if(e(t[n],t[n+1])>0)return!1;return!0}function Y(t,e){return t.index-e.index}V.ERROR_MESSAGE="No tick data provider was given";var Z=function(){function t(){}return t.validateList=function(t,e){e>0||i(!1),t.every((function(t){return t.index%e==0}))||i(!1),r.equal(t.reduce((function(t,e){return r.add(t,e.liquidityNet)}),C),C)||i(!1),z(t,Y)||i(!1)},t.isBelowSmallest=function(t,e){return t.length>0||i(!1),e<t[0].index},t.isAtOrAboveLargest=function(t,e){return t.length>0||i(!1),e>=t[t.length-1].index},t.getTick=function(t,e){var n=t[this.binarySearch(t,e)];return n.index!==e&&i(!1),n},t.binarySearch=function(t,e){this.isBelowSmallest(t,e)&&i(!1);for(var n,r=0,o=t.length-1;;){if(t[n=Math.floor((r+o)/2)].index<=e&&(n===t.length-1||t[n+1].index>e))return n;t[n].index<e?r=n+1:o=n-1}},t.nextInitializedTick=function(e,n,r){return r?(t.isBelowSmallest(e,n)&&i(!1),t.isAtOrAboveLargest(e,n)?e[e.length-1]:e[this.binarySearch(e,n)]):(this.isAtOrAboveLargest(e,n)&&i(!1),this.isBelowSmallest(e,n)?e[0]:e[this.binarySearch(e,n)+1])},t.nextInitializedTickWithinOneWord=function(e,n,r,i){var o=Math.floor(n/i);if(r){var u=(o>>8<<8)*i;if(t.isBelowSmallest(e,n))return[u,!1];var a=t.nextInitializedTick(e,n,r).index,c=Math.max(u,a);return[c,c===a]}var s=((1+(o+1>>8)<<8)-1)*i;if(this.isAtOrAboveLargest(e,n))return[s,!1];var p=this.nextInitializedTick(e,n,r).index,l=Math.min(s,p);return[l,l===p]},t}();function $(t){var e=r.BigInt(t).toString(16);return e.length%2!=0&&(e="0"+e),"0x"+e}function J(t,e){var n=t.pools.reduce((function(t,e,n){var r=t.inputToken,i=t.path,o=t.types,u=e.token0.equals(r)?e.token1:e.token0;return 0===n?{inputToken:u,types:["address","uint24","address"],path:[r.address,e.fee,u.address]}:{inputToken:u,types:[].concat(o,["uint24","address"]),path:[].concat(i,[e.fee,u.address])}}),{inputToken:t.input.wrapped,path:[],types:[]}),r=n.path,i=n.types;return e?a.pack(i.reverse(),r.reverse()):a.pack(i,r)}function tt(t,e){var i=r.leftShift(r.BigInt(t),r.BigInt(192)),o=r.BigInt(e),u=r.divide(i,o);return n.sqrt(u)}function et(t,e,n){if(r.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}var o=r.divide(r.multiply(t,e),S);return r.divide(r.multiply(r.BigInt(n),o),r.subtract(e,t))}function nt(t,e,n){if(r.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}var o=r.multiply(r.multiply(r.BigInt(n),t),e),u=r.multiply(S,r.subtract(e,t));return r.divide(o,u)}function rt(t,e,n){if(r.greaterThan(t,e)){var i=[e,t];t=i[0],e=i[1]}return r.divide(r.multiply(r.BigInt(n),S),r.subtract(e,t))}function it(t,e,n,i,o,u){if(r.greaterThan(e,n)){var a=[n,e];e=a[0],n=a[1]}var c=u?nt:et;if(r.lessThanOrEqual(t,e))return c(e,n,i);if(r.lessThan(t,n)){var s=c(t,n,i),p=rt(e,t,o);return r.lessThan(s,p)?s:p}return rt(e,n,o)}var ot=r.exponentiate(r.BigInt(2),r.BigInt(128)),ut=function(){function t(){}return t.getTokensOwed=function(t,e,n,i,o){return[r.divide(r.multiply(st(i,t),n),ot),r.divide(r.multiply(st(o,e),n),ot)]},t}();function at(t,e,i){var o=Q.getSqrtRatioAtTick(i),u=r.multiply(o,o);return t.sortsBefore(e)?new n.Price(t,e,N,u):new n.Price(t,e,u,N)}var ct=r.exponentiate(r.BigInt(2),r.BigInt(256));function st(t,e){var n=r.subtract(t,e);return r.lessThan(n,C)?r.add(ct,n):n}var pt=function(){function t(){}return t.getFeeGrowthInside=function(t,e,n,r,i,o,u){var a,c,s,p;return i>=n?(a=t.feeGrowthOutside0X128,c=t.feeGrowthOutside1X128):(a=st(o,t.feeGrowthOutside0X128),c=st(u,t.feeGrowthOutside1X128)),i<r?(s=e.feeGrowthOutside0X128,p=e.feeGrowthOutside1X128):(s=st(o,e.feeGrowthOutside0X128),p=st(u,e.feeGrowthOutside1X128)),[st(st(o,a),s),st(st(u,c),p)]},t}(),lt=function(t){var e=t.index,n=t.liquidityGross,o=t.liquidityNet;e>=Q.MIN_TICK&&e<=Q.MAX_TICK||i(!1),this.index=e,this.liquidityGross=r.BigInt(n),this.liquidityNet=r.BigInt(o)},dt=function(){function t(t,e){var n=t.map((function(t){return t instanceof lt?t:new lt(t)}));Z.validateList(n,e),this.ticks=n}var e=t.prototype;return e.getTick=function(){var t=g(v().mark((function t(e){return v().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",Z.getTick(this.ticks,e));case 1:case"end":return t.stop()}}),t,this)})));return function(e){return t.apply(this,arguments)}}(),e.nextInitializedTickWithinOneWord=function(){var t=g(v().mark((function t(e,n,r){return v().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",Z.nextInitializedTickWithinOneWord(this.ticks,e,n,r));case 1:case"end":return t.stop()}}),t,this)})));return function(e,n,r){return t.apply(this,arguments)}}(),t}(),ft=new V,ht=function(){function t(t,e,n,o,u,a,c){void 0===c&&(c=ft),Number.isInteger(n)&&n<1e6||i(!1);var s=Q.getSqrtRatioAtTick(a),p=Q.getSqrtRatioAtTick(a+1);r.greaterThanOrEqual(r.BigInt(o),s)&&r.lessThanOrEqual(r.BigInt(o),p)||i(!1);var l=t.sortsBefore(e)?[t,e]:[e,t];this.token0=l[0],this.token1=l[1],this.fee=n,this.sqrtRatioX96=r.BigInt(o),this.liquidity=r.BigInt(u),this.tickCurrent=a,this.tickDataProvider=Array.isArray(c)?new dt(c,E[n]):c}t.getAddress=function(t,e,n,r,i){return _({factoryAddress:null!=i?i:"0x1F98431c8aD98523631AE4a59f267346ea31F984",fee:n,tokenA:t,tokenB:e,initCodeHashManualOverride:r})};var e=t.prototype;return e.involvesToken=function(t){return t.equals(this.token0)||t.equals(this.token1)},e.priceOf=function(t){return this.involvesToken(t)||i(!1),t.equals(this.token0)?this.token0Price:this.token1Price},e.getOutputAmount=function(){var e=g(v().mark((function e(o,u){var a,c,s,p,l;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return this.involvesToken(o.currency)||i(!1),a=o.currency.equals(this.token0),e.next=4,this.swap(a,o.quotient,u);case 4:return s=(c=e.sent).sqrtRatioX96,p=c.liquidity,l=c.tickCurrent,e.abrupt("return",[n.CurrencyAmount.fromRawAmount(a?this.token1:this.token0,r.multiply(c.amountCalculated,P)),new t(this.token0,this.token1,this.fee,s,p,l,this.tickDataProvider)]);case 11:case"end":return e.stop()}}),e,this)})));return function(t,n){return e.apply(this,arguments)}}(),e.getInputAmount=function(){var e=g(v().mark((function e(o,u){var a,c,s,p,l;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return o.currency.isToken&&this.involvesToken(o.currency)||i(!1),a=o.currency.equals(this.token1),e.next=4,this.swap(a,r.multiply(o.quotient,P),u);case 4:return s=(c=e.sent).sqrtRatioX96,p=c.liquidity,l=c.tickCurrent,e.abrupt("return",[n.CurrencyAmount.fromRawAmount(a?this.token0:this.token1,c.amountCalculated),new t(this.token0,this.token1,this.fee,s,p,l,this.tickDataProvider)]);case 11:case"end":return e.stop()}}),e,this)})));return function(t,n){return e.apply(this,arguments)}}(),e.swap=function(){var t=g(v().mark((function t(e,n,o){var u,a,c,s,p,l;return v().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:o||(o=e?r.add(Q.MIN_SQRT_RATIO,O):r.subtract(Q.MAX_SQRT_RATIO,O)),e?(r.greaterThan(o,Q.MIN_SQRT_RATIO)||i(!1),r.lessThan(o,this.sqrtRatioX96)||i(!1)):(r.lessThan(o,Q.MAX_SQRT_RATIO)||i(!1),r.greaterThan(o,this.sqrtRatioX96)||i(!1)),u=r.greaterThanOrEqual(n,C),a={amountSpecifiedRemaining:n,amountCalculated:C,sqrtPriceX96:this.sqrtRatioX96,tick:this.tickCurrent,liquidity:this.liquidity};case 4:if(!r.notEqual(a.amountSpecifiedRemaining,C)||a.sqrtPriceX96===o){t.next=35;break}return(c={}).sqrtPriceStartX96=a.sqrtPriceX96,t.next=9,this.tickDataProvider.nextInitializedTickWithinOneWord(a.tick,e,this.tickSpacing);case 9:if(c.tickNext=(s=t.sent)[0],c.initialized=s[1],c.tickNext<Q.MIN_TICK?c.tickNext=Q.MIN_TICK:c.tickNext>Q.MAX_TICK&&(c.tickNext=Q.MAX_TICK),c.sqrtPriceNextX96=Q.getSqrtRatioAtTick(c.tickNext),p=D.computeSwapStep(a.sqrtPriceX96,(e?r.lessThan(c.sqrtPriceNextX96,o):r.greaterThan(c.sqrtPriceNextX96,o))?o:c.sqrtPriceNextX96,a.liquidity,a.amountSpecifiedRemaining,this.fee),a.sqrtPriceX96=p[0],c.amountIn=p[1],c.amountOut=p[2],c.feeAmount=p[3],u?(a.amountSpecifiedRemaining=r.subtract(a.amountSpecifiedRemaining,r.add(c.amountIn,c.feeAmount)),a.amountCalculated=r.subtract(a.amountCalculated,c.amountOut)):(a.amountSpecifiedRemaining=r.add(a.amountSpecifiedRemaining,c.amountOut),a.amountCalculated=r.add(a.amountCalculated,r.add(c.amountIn,c.feeAmount))),!r.equal(a.sqrtPriceX96,c.sqrtPriceNextX96)){t.next=32;break}if(!c.initialized){t.next=29;break}return t.t0=r,t.next=25,this.tickDataProvider.getTick(c.tickNext);case 25:t.t1=t.sent.liquidityNet,l=t.t0.BigInt.call(t.t0,t.t1),e&&(l=r.multiply(l,P)),a.liquidity=F.addDelta(a.liquidity,l);case 29:a.tick=e?c.tickNext-1:c.tickNext,t.next=33;break;case 32:r.notEqual(a.sqrtPriceX96,c.sqrtPriceStartX96)&&(a.tick=Q.getTickAtSqrtRatio(a.sqrtPriceX96));case 33:t.next=4;break;case 35:return t.abrupt("return",{amountCalculated:a.amountCalculated,sqrtRatioX96:a.sqrtPriceX96,liquidity:a.liquidity,tickCurrent:a.tick});case 36:case"end":return t.stop()}}),t,this)})));return function(e,n,r){return t.apply(this,arguments)}}(),T(t,[{key:"token0Price",get:function(){var t;return null!=(t=this._token0Price)?t:this._token0Price=new n.Price(this.token0,this.token1,N,r.multiply(this.sqrtRatioX96,this.sqrtRatioX96))}},{key:"token1Price",get:function(){var t;return null!=(t=this._token1Price)?t:this._token1Price=new n.Price(this.token1,this.token0,r.multiply(this.sqrtRatioX96,this.sqrtRatioX96),N)}},{key:"chainId",get:function(){return this.token0.chainId}},{key:"tickSpacing",get:function(){return E[this.fee]}}]),t}(),mt=function(){function t(t){var e=t.pool,n=t.liquidity,o=t.tickLower,u=t.tickUpper;this._token0Amount=null,this._token1Amount=null,this._mintAmounts=null,o<u||i(!1),o>=Q.MIN_TICK&&o%e.tickSpacing==0||i(!1),u<=Q.MAX_TICK&&u%e.tickSpacing==0||i(!1),this.pool=e,this.tickLower=o,this.tickUpper=u,this.liquidity=r.BigInt(n)}var e=t.prototype;return e.ratiosAfterSlippage=function(t){var e=this.pool.token0Price.asFraction.multiply(new n.Percent(1).subtract(t)),i=this.pool.token0Price.asFraction.multiply(t.add(1)),o=tt(e.numerator,e.denominator);r.lessThanOrEqual(o,Q.MIN_SQRT_RATIO)&&(o=r.add(Q.MIN_SQRT_RATIO,r.BigInt(1)));var u=tt(i.numerator,i.denominator);return r.greaterThanOrEqual(u,Q.MAX_SQRT_RATIO)&&(u=r.subtract(Q.MAX_SQRT_RATIO,r.BigInt(1))),{sqrtRatioX96Lower:o,sqrtRatioX96Upper:u}},e.mintAmountsWithSlippage=function(e){var n=this.ratiosAfterSlippage(e),r=n.sqrtRatioX96Upper,i=n.sqrtRatioX96Lower,o=new ht(this.pool.token0,this.pool.token1,this.pool.fee,i,0,Q.getTickAtSqrtRatio(i)),u=new ht(this.pool.token0,this.pool.token1,this.pool.fee,r,0,Q.getTickAtSqrtRatio(r)),a=t.fromAmounts(w({pool:this.pool,tickLower:this.tickLower,tickUpper:this.tickUpper},this.mintAmounts,{useFullPrecision:!1}));return{amount0:new t({pool:u,liquidity:a.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).mintAmounts.amount0,amount1:new t({pool:o,liquidity:a.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).mintAmounts.amount1}},e.burnAmountsWithSlippage=function(e){var n=this.ratiosAfterSlippage(e),r=n.sqrtRatioX96Upper,i=n.sqrtRatioX96Lower,o=new ht(this.pool.token0,this.pool.token1,this.pool.fee,i,0,Q.getTickAtSqrtRatio(i)),u=new t({pool:new ht(this.pool.token0,this.pool.token1,this.pool.fee,r,0,Q.getTickAtSqrtRatio(r)),liquidity:this.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).amount0,a=new t({pool:o,liquidity:this.liquidity,tickLower:this.tickLower,tickUpper:this.tickUpper}).amount1;return{amount0:u.quotient,amount1:a.quotient}},t.fromAmounts=function(e){var n=e.pool,r=e.tickLower,i=e.tickUpper,o=e.amount0,u=e.amount1,a=e.useFullPrecision,c=Q.getSqrtRatioAtTick(r),s=Q.getSqrtRatioAtTick(i);return new t({pool:n,tickLower:r,tickUpper:i,liquidity:it(n.sqrtRatioX96,c,s,o,u,a)})},t.fromAmount0=function(e){return t.fromAmounts({pool:e.pool,tickLower:e.tickLower,tickUpper:e.tickUpper,amount0:e.amount0,amount1:n.MaxUint256,useFullPrecision:e.useFullPrecision})},t.fromAmount1=function(e){return t.fromAmounts({pool:e.pool,tickLower:e.tickLower,tickUpper:e.tickUpper,amount0:n.MaxUint256,amount1:e.amount1,useFullPrecision:!0})},T(t,[{key:"token0PriceLower",get:function(){return at(this.pool.token0,this.pool.token1,this.tickLower)}},{key:"token0PriceUpper",get:function(){return at(this.pool.token0,this.pool.token1,this.tickUpper)}},{key:"amount0",get:function(){return null===this._token0Amount&&(this._token0Amount=n.CurrencyAmount.fromRawAmount(this.pool.token0,this.pool.tickCurrent<this.tickLower?B.getAmount0Delta(Q.getSqrtRatioAtTick(this.tickLower),Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1):this.pool.tickCurrent<this.tickUpper?B.getAmount0Delta(this.pool.sqrtRatioX96,Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1):C)),this._token0Amount}},{key:"amount1",get:function(){return null===this._token1Amount&&(this._token1Amount=n.CurrencyAmount.fromRawAmount(this.pool.token1,this.pool.tickCurrent<this.tickLower?C:B.getAmount1Delta(Q.getSqrtRatioAtTick(this.tickLower),this.pool.tickCurrent<this.tickUpper?this.pool.sqrtRatioX96:Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!1))),this._token1Amount}},{key:"mintAmounts",get:function(){return null===this._mintAmounts?this.pool.tickCurrent<this.tickLower?{amount0:B.getAmount0Delta(Q.getSqrtRatioAtTick(this.tickLower),Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0),amount1:C}:this.pool.tickCurrent<this.tickUpper?{amount0:B.getAmount0Delta(this.pool.sqrtRatioX96,Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0),amount1:B.getAmount1Delta(Q.getSqrtRatioAtTick(this.tickLower),this.pool.sqrtRatioX96,this.liquidity,!0)}:{amount0:C,amount1:B.getAmount1Delta(Q.getSqrtRatioAtTick(this.tickLower),Q.getSqrtRatioAtTick(this.tickUpper),this.liquidity,!0)}:this._mintAmounts}}]),t}(),vt=function(){function t(t,e,n){this._midPrice=null,t.length>0||i(!1);var r=t[0].chainId;t.every((function(t){return t.chainId===r}))||i(!1);var o=e.wrapped;t[0].involvesToken(o)||i(!1),t[t.length-1].involvesToken(n.wrapped)||i(!1);for(var u,a=[o],c=x(t.entries());!(u=c()).done;){var s=u.value,p=s[1],l=a[s[0]];l.equals(p.token0)||l.equals(p.token1)||i(!1);var d=l.equals(p.token0)?p.token1:p.token0;a.push(d)}this.pools=t,this.tokenPath=a,this.input=e,this.output=null!=n?n:a[a.length-1]}return T(t,[{key:"chainId",get:function(){return this.pools[0].chainId}},{key:"midPrice",get:function(){if(null!==this._midPrice)return this._midPrice;var t=this.pools.slice(1).reduce((function(t,e){var n=t.price;return t.nextInput.equals(e.token0)?{nextInput:e.token1,price:n.multiply(e.token0Price)}:{nextInput:e.token0,price:n.multiply(e.token1Price)}}),this.pools[0].token0.equals(this.input.wrapped)?{nextInput:this.pools[0].token1,price:this.pools[0].token0Price}:{nextInput:this.pools[0].token0,price:this.pools[0].token1Price}).price;return this._midPrice=new n.Price(this.input,this.output,t.denominator,t.numerator)}}]),t}();function yt(t,e){return t.inputAmount.currency.equals(e.inputAmount.currency)||i(!1),t.outputAmount.currency.equals(e.outputAmount.currency)||i(!1),t.outputAmount.equalTo(e.outputAmount)?t.inputAmount.equalTo(e.inputAmount)?t.swaps.reduce((function(t,e){return t+e.route.tokenPath.length}),0)-e.swaps.reduce((function(t,e){return t+e.route.tokenPath.length}),0):t.inputAmount.lessThan(e.inputAmount)?-1:1:t.outputAmount.lessThan(e.outputAmount)?1:-1}var kt=function(){function t(t){var e=t.routes,n=t.tradeType,r=e[0].inputAmount.currency,o=e[0].outputAmount.currency;e.every((function(t){return r.wrapped.equals(t.route.input.wrapped)}))||i(!1),e.every((function(t){return o.wrapped.equals(t.route.output.wrapped)}))||i(!1);for(var u,a=e.map((function(t){return t.route.pools.length})).reduce((function(t,e){return t+e}),0),c=new Set,s=x(e);!(u=s()).done;)for(var p,l=x(u.value.route.pools);!(p=l()).done;){var d=p.value;c.add(ht.getAddress(d.token0,d.token1,d.fee))}a!==c.size&&i(!1),this.swaps=e,this.tradeType=n}t.exactIn=function(){var e=g(v().mark((function e(r,i){return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",t.fromRoute(r,i,n.TradeType.EXACT_INPUT));case 1:case"end":return e.stop()}}),e)})));return function(t,n){return e.apply(this,arguments)}}(),t.exactOut=function(){var e=g(v().mark((function e(r,i){return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",t.fromRoute(r,i,n.TradeType.EXACT_OUTPUT));case 1:case"end":return e.stop()}}),e)})));return function(t,n){return e.apply(this,arguments)}}(),t.fromRoute=function(){var e=g(v().mark((function e(r,o,u){var a,c,s,p,l,d,f;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(a=new Array(r.tokenPath.length),u!==n.TradeType.EXACT_INPUT){e.next=19;break}o.currency.equals(r.input)||i(!1),a[0]=o.wrapped,p=0;case 5:if(!(p<r.tokenPath.length-1)){e.next=15;break}return l=r.pools[p],e.next=9,l.getOutputAmount(a[p]);case 9:a[p+1]=e.sent[0];case 12:p++,e.next=5;break;case 15:c=n.CurrencyAmount.fromFractionalAmount(r.input,o.numerator,o.denominator),s=n.CurrencyAmount.fromFractionalAmount(r.output,a[a.length-1].numerator,a[a.length-1].denominator),e.next=34;break;case 19:o.currency.equals(r.output)||i(!1),a[a.length-1]=o.wrapped,d=r.tokenPath.length-1;case 22:if(!(d>0)){e.next=32;break}return f=r.pools[d-1],e.next=26,f.getInputAmount(a[d]);case 26:a[d-1]=e.sent[0];case 29:d--,e.next=22;break;case 32:c=n.CurrencyAmount.fromFractionalAmount(r.input,a[0].numerator,a[0].denominator),s=n.CurrencyAmount.fromFractionalAmount(r.output,o.numerator,o.denominator);case 34:return e.abrupt("return",new t({routes:[{inputAmount:c,outputAmount:s,route:r}],tradeType:u}));case 35:case"end":return e.stop()}}),e)})));return function(t,n,r){return e.apply(this,arguments)}}(),t.fromRoutes=function(){var e=g(v().mark((function e(r,o){var u,a,c,s,p,l,d,f,h,m,y,k,g;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:u=[],a=x(r);case 2:if((c=a()).done){e.next=43;break}if(p=(s=c.value).route,l=s.amount,d=new Array(p.tokenPath.length),f=void 0,h=void 0,o!==n.TradeType.EXACT_INPUT){e.next=25;break}l.currency.equals(p.input)||i(!1),f=n.CurrencyAmount.fromFractionalAmount(p.input,l.numerator,l.denominator),d[0]=n.CurrencyAmount.fromFractionalAmount(p.input.wrapped,l.numerator,l.denominator),m=0;case 12:if(!(m<p.tokenPath.length-1)){e.next=22;break}return y=p.pools[m],e.next=16,y.getOutputAmount(d[m]);case 16:d[m+1]=e.sent[0];case 19:m++,e.next=12;break;case 22:h=n.CurrencyAmount.fromFractionalAmount(p.output,d[d.length-1].numerator,d[d.length-1].denominator),e.next=40;break;case 25:l.currency.equals(p.output)||i(!1),h=n.CurrencyAmount.fromFractionalAmount(p.output,l.numerator,l.denominator),d[d.length-1]=n.CurrencyAmount.fromFractionalAmount(p.output.wrapped,l.numerator,l.denominator),k=p.tokenPath.length-1;case 29:if(!(k>0)){e.next=39;break}return g=p.pools[k-1],e.next=33,g.getInputAmount(d[k]);case 33:d[k-1]=e.sent[0];case 36:k--,e.next=29;break;case 39:f=n.CurrencyAmount.fromFractionalAmount(p.input,d[0].numerator,d[0].denominator);case 40:u.push({route:p,inputAmount:f,outputAmount:h});case 41:e.next=2;break;case 43:return e.abrupt("return",new t({routes:u,tradeType:o}));case 44:case"end":return e.stop()}}),e)})));return function(t,n){return e.apply(this,arguments)}}(),t.createUncheckedTrade=function(e){return new t(w({},e,{routes:[{inputAmount:e.inputAmount,outputAmount:e.outputAmount,route:e.route}]}))},t.createUncheckedTradeWithMultipleRoutes=function(e){return new t(e)};var e=t.prototype;return e.minimumAmountOut=function(t,e){if(void 0===e&&(e=this.outputAmount),t.lessThan(C)&&i(!1),this.tradeType===n.TradeType.EXACT_OUTPUT)return e;var r=new n.Fraction(O).add(t).invert().multiply(e.quotient).quotient;return n.CurrencyAmount.fromRawAmount(e.currency,r)},e.maximumAmountIn=function(t,e){if(void 0===e&&(e=this.inputAmount),t.lessThan(C)&&i(!1),this.tradeType===n.TradeType.EXACT_INPUT)return e;var r=new n.Fraction(O).add(t).multiply(e.quotient).quotient;return n.CurrencyAmount.fromRawAmount(e.currency,r)},e.worstExecutionPrice=function(t){return new n.Price(this.inputAmount.currency,this.outputAmount.currency,this.maximumAmountIn(t).quotient,this.minimumAmountOut(t).quotient)},t.bestTradeExactIn=function(){var e=g(v().mark((function e(r,o,u,a,c,s,p){var l,d,f,h,m,y,k,g,A,T,w;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:f=void 0===(d=(l=void 0===a?{}:a).maxNumResults)?3:d,m=void 0===(h=l.maxHops)?3:h,void 0===c&&(c=[]),void 0===s&&(s=o),void 0===p&&(p=[]),r.length>0||i(!1),m>0||i(!1),o===s||c.length>0||i(!1),y=s.wrapped,k=u.wrapped,g=0;case 10:if(!(g<r.length)){e.next=46;break}if((A=r[g]).token0.equals(y.currency)||A.token1.equals(y.currency)){e.next=14;break}return e.abrupt("continue",43);case 14:return T=void 0,e.prev=15,e.next=19,A.getOutputAmount(y);case 19:T=e.sent[0],e.next=28;break;case 23:if(e.prev=23,e.t0=e.catch(15),!e.t0.isInsufficientInputAmountError){e.next=27;break}return e.abrupt("continue",43);case 27:throw e.t0;case 28:if(!T.currency.isToken||!T.currency.equals(k)){e.next=39;break}return e.t1=n.sortedInsert,e.t2=p,e.next=33,t.fromRoute(new vt([].concat(c,[A]),o.currency,u),o,n.TradeType.EXACT_INPUT);case 33:e.t3=e.sent,e.t4=f,e.t5=yt,(0,e.t1)(e.t2,e.t3,e.t4,e.t5),e.next=43;break;case 39:if(!(m>1&&r.length>1)){e.next=43;break}return w=r.slice(0,g).concat(r.slice(g+1,r.length)),e.next=43,t.bestTradeExactIn(w,o,u,{maxNumResults:f,maxHops:m-1},[].concat(c,[A]),T,p);case 43:g++,e.next=10;break;case 46:return e.abrupt("return",p);case 47:case"end":return e.stop()}}),e,null,[[15,23]])})));return function(t,n,r,i,o,u,a){return e.apply(this,arguments)}}(),t.bestTradeExactOut=function(){var e=g(v().mark((function e(r,o,u,a,c,s,p){var l,d,f,h,m,y,k,g,A,T,w;return v().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:f=void 0===(d=(l=void 0===a?{}:a).maxNumResults)?3:d,m=void 0===(h=l.maxHops)?3:h,void 0===c&&(c=[]),void 0===s&&(s=u),void 0===p&&(p=[]),r.length>0||i(!1),m>0||i(!1),u===s||c.length>0||i(!1),y=s.wrapped,k=o.wrapped,g=0;case 10:if(!(g<r.length)){e.next=46;break}if((A=r[g]).token0.equals(y.currency)||A.token1.equals(y.currency)){e.next=14;break}return e.abrupt("continue",43);case 14:return T=void 0,e.prev=15,e.next=19,A.getInputAmount(y);case 19:T=e.sent[0],e.next=28;break;case 23:if(e.prev=23,e.t0=e.catch(15),!e.t0.isInsufficientReservesError){e.next=27;break}return e.abrupt("continue",43);case 27:throw e.t0;case 28:if(!T.currency.equals(k)){e.next=39;break}return e.t1=n.sortedInsert,e.t2=p,e.next=33,t.fromRoute(new vt([A].concat(c),o,u.currency),u,n.TradeType.EXACT_OUTPUT);case 33:e.t3=e.sent,e.t4=f,e.t5=yt,(0,e.t1)(e.t2,e.t3,e.t4,e.t5),e.next=43;break;case 39:if(!(m>1&&r.length>1)){e.next=43;break}return w=r.slice(0,g).concat(r.slice(g+1,r.length)),e.next=43,t.bestTradeExactOut(w,o,u,{maxNumResults:f,maxHops:m-1},[A].concat(c),T,p);case 43:g++,e.next=10;break;case 46:return e.abrupt("return",p);case 47:case"end":return e.stop()}}),e,null,[[15,23]])})));return function(t,n,r,i,o,u,a){return e.apply(this,arguments)}}(),T(t,[{key:"route",get:function(){return 1!==this.swaps.length&&i(!1),this.swaps[0].route}},{key:"inputAmount",get:function(){if(this._inputAmount)return this._inputAmount;var t=this.swaps[0].inputAmount.currency,e=this.swaps.map((function(t){return t.inputAmount})).reduce((function(t,e){return t.add(e)}),n.CurrencyAmount.fromRawAmount(t,0));return this._inputAmount=e,this._inputAmount}},{key:"outputAmount",get:function(){if(this._outputAmount)return this._outputAmount;var t=this.swaps[0].outputAmount.currency,e=this.swaps.map((function(t){return t.outputAmount})).reduce((function(t,e){return t.add(e)}),n.CurrencyAmount.fromRawAmount(t,0));return this._outputAmount=e,this._outputAmount}},{key:"executionPrice",get:function(){var t;return null!=(t=this._executionPrice)?t:this._executionPrice=new n.Price(this.inputAmount.currency,this.outputAmount.currency,this.inputAmount.quotient,this.outputAmount.quotient)}},{key:"priceImpact",get:function(){if(this._priceImpact)return this._priceImpact;for(var t,e=n.CurrencyAmount.fromRawAmount(this.outputAmount.currency,0),r=x(this.swaps);!(t=r()).done;){var i=t.value;e=e.add(i.route.midPrice.quote(i.inputAmount))}var o=e.subtract(this.outputAmount).divide(e);return this._priceImpact=new n.Percent(o.numerator,o.denominator),this._priceImpact}}]),t}(),gt=function(){function t(){}return t.encodeMulticall=function(e){return Array.isArray(e)||(e=[e]),1===e.length?e[0]:t.INTERFACE.encodeFunctionData("multicall",[e])},t}();gt.INTERFACE=new o.Interface(c.abi);var At=function(){function t(){}return t.encodePermit=function(e,n){return"nonce"in n?t.INTERFACE.encodeFunctionData("selfPermitAllowed",[e.address,$(n.nonce),$(n.expiry),n.v,n.r,n.s]):t.INTERFACE.encodeFunctionData("selfPermit",[e.address,$(n.amount),$(n.deadline),n.v,n.r,n.s])},t}();At.INTERFACE=new o.Interface(p.abi);var Tt=function(){function t(){}return t.encodeFeeBips=function(t){return $(t.multiply(1e4).quotient)},t.encodeUnwrapWETH9=function(e,r,i){if(r=n.validateAndParseAddress(r),i){var o=this.encodeFeeBips(i.fee),u=n.validateAndParseAddress(i.recipient);return t.INTERFACE.encodeFunctionData("unwrapWETH9WithFee",[$(e),r,o,u])}return t.INTERFACE.encodeFunctionData("unwrapWETH9",[$(e),r])},t.encodeSweepToken=function(e,r,i,o){if(i=n.validateAndParseAddress(i),o){var u=this.encodeFeeBips(o.fee),a=n.validateAndParseAddress(o.recipient);return t.INTERFACE.encodeFunctionData("sweepTokenWithFee",[e.address,$(r),i,u,a])}return t.INTERFACE.encodeFunctionData("sweepToken",[e.address,$(r),i])},t.encodeRefundETH=function(){return t.INTERFACE.encodeFunctionData("refundETH")},t}();Tt.INTERFACE=new o.Interface(l.abi);var wt=["expectedCurrencyOwed0","expectedCurrencyOwed1"],It=$(r.subtract(r.exponentiate(r.BigInt(2),r.BigInt(128)),r.BigInt(1)));function xt(t){return Object.keys(t).some((function(t){return"recipient"===t}))}var qt=function(){function t(){}return t.encodeCreate=function(e){return t.INTERFACE.encodeFunctionData("createAndInitializePoolIfNecessary",[e.token0.address,e.token1.address,e.fee,$(e.sqrtRatioX96)])},t.createCallParameters=function(t){return{calldata:this.encodeCreate(t),value:$(0)}},t.addCallParameters=function(e,o){r.greaterThan(e.liquidity,C)||i(!1);var u=[],a=$(0),c=e.mintAmounts,s=c.amount0,p=c.amount1,l=e.mintAmountsWithSlippage(o.slippageTolerance),d=$(l.amount0),f=$(l.amount1),h=$(o.deadline);if(xt(o)&&o.createPool&&(u.push(this.encodeCreate(e.pool)),a=r.BigInt("1024000000000000000000").toString(16)),o.token0Permit&&u.push(At.encodePermit(e.pool.token0,o.token0Permit)),o.token1Permit&&u.push(At.encodePermit(e.pool.token1,o.token1Permit)),xt(o)){var m=n.validateAndParseAddress(o.recipient);u.push(t.INTERFACE.encodeFunctionData("mint",[{token0:e.pool.token0.address,token1:e.pool.token1.address,fee:e.pool.fee,tickLower:e.tickLower,tickUpper:e.tickUpper,amount0Desired:$(s),amount1Desired:$(p),amount0Min:d,amount1Min:f,recipient:m,deadline:h}]))}else u.push(t.INTERFACE.encodeFunctionData("increaseLiquidity",[{tokenId:$(o.tokenId),amount0Desired:$(s),amount1Desired:$(p),amount0Min:d,amount1Min:f,deadline:h}]));if(o.useNative){var v=o.useNative.wrapped;e.pool.token0.equals(v)||e.pool.token1.equals(v)||i(!1);var y=e.pool.token0.equals(v)?s:p;r.greaterThan(y,C)&&u.push(Tt.encodeRefundETH()),a=$(y)}return{calldata:gt.encodeMulticall(u),value:a}},t.encodeCollect=function(e){var r=[],i=$(e.tokenId),o=e.expectedCurrencyOwed0.currency.isNative||e.expectedCurrencyOwed1.currency.isNative,u=n.validateAndParseAddress(e.recipient);if(r.push(t.INTERFACE.encodeFunctionData("collect",[{tokenId:i,recipient:o?b:u,amount0Max:It,amount1Max:It}])),o){var a=e.expectedCurrencyOwed0.currency.isNative?e.expectedCurrencyOwed1.currency:e.expectedCurrencyOwed0.currency,c=e.expectedCurrencyOwed0.currency.isNative?e.expectedCurrencyOwed1.quotient:e.expectedCurrencyOwed0.quotient;r.push(Tt.encodeUnwrapWETH9(e.expectedCurrencyOwed0.currency.isNative?e.expectedCurrencyOwed0.quotient:e.expectedCurrencyOwed1.quotient,u)),r.push(Tt.encodeSweepToken(a,c,u))}return r},t.collectCallParameters=function(e){var n=t.encodeCollect(e);return{calldata:gt.encodeMulticall(n),value:$(0)}},t.removeCallParameters=function(e,o){var u=[],a=$(o.deadline),c=$(o.tokenId),s=new mt({pool:e.pool,liquidity:o.liquidityPercentage.multiply(e.liquidity).quotient,tickLower:e.tickLower,tickUpper:e.tickUpper});r.greaterThan(s.liquidity,C)||i(!1);var p=s.burnAmountsWithSlippage(o.slippageTolerance),l=p.amount0,d=p.amount1;o.permit&&u.push(t.INTERFACE.encodeFunctionData("permit",[n.validateAndParseAddress(o.permit.spender),c,$(o.permit.deadline),o.permit.v,o.permit.r,o.permit.s])),u.push(t.INTERFACE.encodeFunctionData("decreaseLiquidity",[{tokenId:c,liquidity:$(s.liquidity),amount0Min:$(l),amount1Min:$(d),deadline:a}]));var f=o.collectOptions,h=f.expectedCurrencyOwed0,m=f.expectedCurrencyOwed1,v=function(t,e){if(null==t)return{};var n,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)e.indexOf(n=o[r])>=0||(i[n]=t[n]);return i}(f,wt);return u.push.apply(u,t.encodeCollect(w({tokenId:$(o.tokenId),expectedCurrencyOwed0:h.add(n.CurrencyAmount.fromRawAmount(h.currency,l)),expectedCurrencyOwed1:m.add(n.CurrencyAmount.fromRawAmount(m.currency,d))},v))),o.liquidityPercentage.equalTo(O)?o.burnToken&&u.push(t.INTERFACE.encodeFunctionData("burn",[c])):!0===o.burnToken&&i(!1),{calldata:gt.encodeMulticall(u),value:$(0)}},t.safeTransferFromParameters=function(e){var r=n.validateAndParseAddress(e.recipient),i=n.validateAndParseAddress(e.sender);return{calldata:e.data?t.INTERFACE.encodeFunctionData("safeTransferFrom(address,address,uint256,bytes)",[i,r,$(e.tokenId),e.data]):t.INTERFACE.encodeFunctionData("safeTransferFrom(address,address,uint256)",[i,r,$(e.tokenId)]),value:$(0)}},t}();qt.INTERFACE=new o.Interface(s.abi);var bt=function(){function t(){}return t.quoteCallParameters=function(t,e,r,o){void 0===o&&(o={});var u,a=1===t.pools.length,c=$(e.quotient),s=o.useQuoterV2?this.V2INTERFACE:this.V1INTERFACE;if(a){var p,l,d={tokenIn:t.tokenPath[0].address,tokenOut:t.tokenPath[1].address,fee:t.pools[0].fee,sqrtPriceLimitX96:$(null!=(p=null==(l=o)?void 0:l.sqrtPriceLimitX96)?p:0)},f=w({},d,r===n.TradeType.EXACT_INPUT?{amountIn:c}:{amount:c});u=s.encodeFunctionData(r===n.TradeType.EXACT_INPUT?"quoteExactInputSingle":"quoteExactOutputSingle",o.useQuoterV2?[f]:[d.tokenIn,d.tokenOut,d.fee,c,d.sqrtPriceLimitX96])}else{var h;void 0!==(null==(h=o)?void 0:h.sqrtPriceLimitX96)&&i(!1);var m=J(t,r===n.TradeType.EXACT_OUTPUT);u=s.encodeFunctionData(r===n.TradeType.EXACT_INPUT?"quoteExactInput":"quoteExactOutput",[m,c])}return{calldata:u,value:$(0)}},t}();bt.V1INTERFACE=new o.Interface(d.abi),bt.V2INTERFACE=new o.Interface(f.abi);var Rt=function(){function t(){}return t.encodeClaim=function(e,r){var i,o=[];o.push(t.INTERFACE.encodeFunctionData("unstakeToken",[this._encodeIncentiveKey(e),$(r.tokenId)]));var u=n.validateAndParseAddress(r.recipient),a=null!=(i=r.amount)?i:0;return o.push(t.INTERFACE.encodeFunctionData("claimReward",[e.rewardToken.address,u,$(a)])),o},t.collectRewards=function(e,n){e=Array.isArray(e)?e:[e];for(var r=[],i=0;i<e.length;i++){var o=e[i];(r=r.concat(this.encodeClaim(o,n))).push(t.INTERFACE.encodeFunctionData("stakeToken",[this._encodeIncentiveKey(o),$(n.tokenId)]))}return{calldata:gt.encodeMulticall(r),value:$(0)}},t.withdrawToken=function(e,r){var i=[];e=Array.isArray(e)?e:[e];for(var o={tokenId:r.tokenId,recipient:r.recipient,amount:r.amount},u=0;u<e.length;u++)i=i.concat(this.encodeClaim(e[u],o));var a=n.validateAndParseAddress(r.owner);return i.push(t.INTERFACE.encodeFunctionData("withdrawToken",[$(r.tokenId),a,r.data?r.data:$(0)])),{calldata:gt.encodeMulticall(i),value:$(0)}},t.encodeDeposit=function(e){var n;if((e=Array.isArray(e)?e:[e]).length>1){for(var r=[],i=0;i<e.length;i++)r.push(this._encodeIncentiveKey(e[i]));n=o.defaultAbiCoder.encode([t.INCENTIVE_KEY_ABI+"[]"],[r])}else n=o.defaultAbiCoder.encode([t.INCENTIVE_KEY_ABI],[this._encodeIncentiveKey(e[0])]);return n},t._encodeIncentiveKey=function(t){var e=t.pool,r=e.token0,i=e.token1,o=e.fee,u=n.validateAndParseAddress(t.refundee);return{rewardToken:t.rewardToken.address,pool:ht.getAddress(r,i,o),startTime:$(t.startTime),endTime:$(t.endTime),refundee:u}},t}();Rt.INTERFACE=new o.Interface(h.abi),Rt.INCENTIVE_KEY_ABI="tuple(address rewardToken, address pool, uint256 startTime, uint256 endTime, address refundee)";var Et=function(){function t(){}return t.swapCallParameters=function(e,r){Array.isArray(e)||(e=[e]);var o=e[0],u=o.inputAmount.currency.wrapped,a=o.outputAmount.currency.wrapped;e.every((function(t){return t.inputAmount.currency.wrapped.equals(u)}))||i(!1),e.every((function(t){return t.outputAmount.currency.wrapped.equals(a)}))||i(!1);var c=[],s=n.CurrencyAmount.fromRawAmount(e[0].inputAmount.currency,0),p=n.CurrencyAmount.fromRawAmount(e[0].outputAmount.currency,0),l=e.reduce((function(t,e){return t.add(e.minimumAmountOut(r.slippageTolerance))}),p),d=o.inputAmount.currency.isNative&&o.tradeType===n.TradeType.EXACT_OUTPUT,f=o.outputAmount.currency.isNative,h=f||!!r.fee,m=o.inputAmount.currency.isNative?e.reduce((function(t,e){return t.add(e.maximumAmountIn(r.slippageTolerance))}),s):s;r.inputTokenPermit&&(o.inputAmount.currency.isToken||i(!1),c.push(At.encodePermit(o.inputAmount.currency,r.inputTokenPermit)));for(var v,y=n.validateAndParseAddress(r.recipient),k=$(r.deadline),g=x(e);!(v=g()).done;)for(var A,T=v.value,w=x(T.swaps);!(A=w()).done;){var I=A.value,q=I.route,R=I.outputAmount,E=$(T.maximumAmountIn(r.slippageTolerance,I.inputAmount).quotient),P=$(T.minimumAmountOut(r.slippageTolerance,R).quotient);if(1===q.pools.length)if(T.tradeType===n.TradeType.EXACT_INPUT){var C,O={tokenIn:q.tokenPath[0].address,tokenOut:q.tokenPath[1].address,fee:q.pools[0].fee,recipient:h?b:y,deadline:k,amountIn:E,amountOutMinimum:P,sqrtPriceLimitX96:$(null!=(C=r.sqrtPriceLimitX96)?C:0)};c.push(t.INTERFACE.encodeFunctionData("exactInputSingle",[O]))}else{var S,N={tokenIn:q.tokenPath[0].address,tokenOut:q.tokenPath[1].address,fee:q.pools[0].fee,recipient:h?b:y,deadline:k,amountOut:P,amountInMaximum:E,sqrtPriceLimitX96:$(null!=(S=r.sqrtPriceLimitX96)?S:0)};c.push(t.INTERFACE.encodeFunctionData("exactOutputSingle",[N]))}else{void 0!==r.sqrtPriceLimitX96&&i(!1);var _=J(q,T.tradeType===n.TradeType.EXACT_OUTPUT);c.push(T.tradeType===n.TradeType.EXACT_INPUT?t.INTERFACE.encodeFunctionData("exactInput",[{path:_,recipient:h?b:y,deadline:k,amountIn:E,amountOutMinimum:P}]):t.INTERFACE.encodeFunctionData("exactOutput",[{path:_,recipient:h?b:y,deadline:k,amountOut:P,amountInMaximum:E}]))}}return h&&c.push(r.fee?f?Tt.encodeUnwrapWETH9(l.quotient,y,r.fee):Tt.encodeSweepToken(o.outputAmount.currency.wrapped,l.quotient,y,r.fee):Tt.encodeUnwrapWETH9(l.quotient,y)),d&&c.push(Tt.encodeRefundETH()),{calldata:gt.encodeMulticall(c),value:$(m.quotient)}},t}();Et.INTERFACE=new o.Interface(m.abi),exports.ADDRESS_ZERO=b,exports.FACTORY_ADDRESS="0x1F98431c8aD98523631AE4a59f267346ea31F984",exports.FullMath=X,exports.LiquidityMath=F,exports.Multicall=gt,exports.NoTickDataProvider=V,exports.NonfungiblePositionManager=qt,exports.POOL_INIT_CODE_HASH=R,exports.Payments=Tt,exports.Pool=ht,exports.Position=mt,exports.PositionLibrary=ut,exports.Route=vt,exports.SelfPermit=At,exports.SqrtPriceMath=B,exports.Staker=Rt,exports.SwapMath=D,exports.SwapQuoter=bt,exports.SwapRouter=Et,exports.TICK_SPACINGS=E,exports.Tick=lt,exports.TickLibrary=pt,exports.TickList=Z,exports.TickListDataProvider=dt,exports.TickMath=Q,exports.Trade=kt,exports.computePoolAddress=_,exports.encodeRouteToPath=J,exports.encodeSqrtRatioX96=tt,exports.isSorted=z,exports.maxLiquidityForAmounts=it,exports.mostSignificantBit=G,exports.nearestUsableTick=function(t,e){Number.isInteger(t)&&Number.isInteger(e)||i(!1),e>0||i(!1),t>=Q.MIN_TICK&&t<=Q.MAX_TICK||i(!1);var n=Math.round(t/e)*e;return n<Q.MIN_TICK?n+e:n>Q.MAX_TICK?n-e:n},exports.priceToClosestTick=function(t){var e=t.baseCurrency.sortsBefore(t.quoteCurrency),n=e?tt(t.numerator,t.denominator):tt(t.denominator,t.numerator),r=Q.getTickAtSqrtRatio(n),i=at(t.baseCurrency,t.quoteCurrency,r+1);return e?t.lessThan(i)||r++:t.greaterThan(i)||r++,r},exports.subIn256=st,exports.tickToPrice=at,exports.toHex=$,exports.tradeComparator=yt;
 //# sourceMappingURL=v3-sdk.cjs.production.min.js.map
